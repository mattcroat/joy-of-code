---
title: 'TypeScript Fundamentals'
description: Learn TypeScript
published: '2021-7-7'
category: 'TypeScript'
image: '/images/typescript-fundamentals/og-image.webp'
---

# TypeScript Fundamentals

If you're learning TypeScript for the first time or need a refresher this is the resource for you.

There's a lot of great resources out there for learning TypeScript, but I always felt they use abstract examples that are hard to relate to and don't explain how to help yourself to figure out types.

That being said nothing can substitute the experience of using TypeScript in your project, so dust off an old JavaScript project or create a new one to learn from.

_note: This one was a massive one to write so there might be more typos than usual (the code checks out üí™) ‚Äî I plan to go over everything and improve it even more over time, so thank you for any contribution you might have._

## Table of Contents

1.  [You're Already Using TypeScript](#youre-already-using-typescript)
2.  [Why Should You Use TypeScript?](#why-should-you-use-typescript)
3.  [Runtime and Compile Time](#runtime-and-compile-time)
4.  [Gradual Adoption](#gradual-adoption)
5.  [TypeScript Introduction Summary](#typescript-introduction-summary)
6.  [JavaScript Types](#javascript-types)
7.  [TypeScript Playground](#typescript-playground)
8.  [Type Inference](#type-inference)
9.  [Type Annotations](#type-annotations)
10. [Primitive Types](#primitive-types)
11. [TypeScript Types](#typescript-types)
12. [any](#any)
13. [unknown](#unknown)
14. [void](#void)
15. [never](#never)
16. [Array Types](#array-types)
17. [Function Types](#function-types)
18. [Function Overloads](#function-overloads)
19. [Object Types](#object-types)
20. [Union Types](#union-types)
21. [Discriminated Unions](#discriminated-unions)
22. [Type Aliases](#type-aliases)
23. [Interfaces](#interfaces)
24. [Type Aliases or Interfaces?](#type-aliases-or-interfaces)
25. [Intersection Types](#intersection-types)
26. [Type Assertion](#type-assertion)
27. [Type Assertion Using `!`](#type-assertion-using-)
28. [Type Assertion Conversion](#type-assertion-conversion)
29. [Literal Types](#literal-types)
30. [Literal Inference](#literal-inference)
31. [Object Index Signatures](#object-index-signatures)
32. [Type Narrowing](#type-narrowing)
33. [Type Guards](#type-guards)
34. [Type Predicates](#type-predicates)
35. [Generics](#generics)
36. [Generic Interface](#generic-interface)
37. [Generic Constraints](#generic-constraints)
38. [Generic Constraints Using Type Parameters](#generic-constraints-using-type-parameters)
39. [Enums](#enums)
40. [Tuple](#tuple)
41. [Classes](#classes)
42. [Set Up TypeScript](#set-up-typescript)
43. [Reading Type Definitions](#reading-type-definitions)
44. [Reading TypeScript Errors](#reading-typescript-errors)
45. [Dealing With Untyped Libraries](#dealing-with-untyped-libraries)
46. [Generate Types](#generate-types)
47. [Closing Thoughts](#closing-thoughts)

## You're Already Using TypeScript

Have you asked yourself how code completion in your editor works?

```js:example.js
const pokemon = ['Bulbasaur', 'Charmander', 'Squirtle']
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/01-hover-type.png"
  alt="Type on hover"
/>

The editor understands that `pokemon` is an **array** of strings.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/02-intellisense.png"
  alt="Intellisense"
/>

Since `pokemon` is an **array** the [editor intellisense](https://code.visualstudio.com/docs/editor/intellisense) is smart enough to only show us **array** methods.

Imagine not having this feature. You would have to remember and look every method up on the [MDN Web Docs](https://developer.mozilla.org/en-US/).

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/03-signature-call.png"
  alt="Signature call"
/>

If we look at the `map` array method we can see it's **call signature** and description in the tooltip.

This is **JavaScript** ‚Äî yet it's using **TypeScript** under the hood.

TypeScript isn't just about types. It's the entire developer experience it brings.

We can add `@ts-check` to the top of our file to enable TypeScript checking in JavaScript.

```js:example.js
// @ts-check

const pokemon = ['Bulbasaur', 'Charmander', 'Squirtle']

pokemon.push(1) // oops! üö´
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/04-ts-error.png"
  alt="TypeScript error"
/>

The `pokemon` array contains only strings, so we get a type error when trying to assign `number` to `string`.

The VS Code editor uses the **TypeScript language server** under the hood.

<Image
  height={1052}
  width={1920}
  src="/images/typescript-fundamentals/05-built-in-extensions.png"
  alt="Built-in extensions"
/>

If we look at the built-in extensions, we can notice some usual suspects. Look, it's [Emmet](https://www.emmet.io/)!

The language server provides us with sophisticated features such as **code completion**, **refactoring**, **syntax highlighting**, and **error and warnings**.

> The Language Server Protocol allows for decoupling language services from the editor so that the services may be contained within a general- purpose language server. Any editor can inherit sophisticated support for many different languages by making use of existing language servers. Similarly, a programmer involved with the development of a new programming language can make services for that language available to existing editing tools. ‚Äî [Language Server Protocol (Wikipedia)](https://en.wikipedia.org/wiki/Language_Server_Protocol).

[Visual Studio Code](https://code.visualstudio.com/) and [TypeScript](https://www.typescriptlang.org/) are made by Microsoft, so that explains the tight integration. This doesn't mean you're left in the dark if you're using another editor like [WebStorm](https://www.jetbrains.com/webstorm/) or [Vim](https://www.vim.org/). The **TypeScript language server** is available as a plugin for those editors.

Your editor already has some amazing features that get enhanced by TypeScript:

- **Auto imports** (as you type imports get added)
- **Code navigation** (definitions, lookup)
- **Rename** (rename symbols across file)
- **Refactoring** (extracting code to functions)
- **Quick fixes** (suggested edits like fixing a mispelled property name)
- **Code suggestions** (for example converting `.then` to use `async` and `await`)

You can learn more in-depth if you read [documentation for the JavaScript language](https://code.visualstudio.com/docs/languages/javascript).

## Why Should You Use TypeScript?

When writing JavaScript we don't get a lot of information before we run our code.

There's no way for us to know if the code has errors until we see the result on the page and go back to our code editor to fix the mistake and rerun the code.

```js:example.js
const pikachu = {
  name: 'Pikachu',
  weight: 60
}

pikachu.weigth // oops! üö´
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/06-no-checking.png"
  alt="No checking"
/>

To prove my point I'm sure you barely noticed the mistake and had to look at what it was.

The editor didn't warn us about mispelling `weight`.

Imagine the same scenario with an API where you pass wrong arguments to a method. You just hope it works.

```js:example.js
// @ts-check

const pikachu = {
  name: 'Pikachu',
  weight: 60
}

pikachu.weigth // ü§î Did you mean 'weight'?
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/07-checking.png"
  alt="Checking"
/>

The editor code completion already makes it harder to make such a mistake writing regular JavaScript because of the benefits we get from TypeScript under the hood. When we do there's nothing to warn us.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/08-quick-fix.png"
  alt="Quick fix"
/>

**Quick fix** can be useful in many situations.

> The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. ‚Äî [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)

TypeScript only gives us information before we run the code. That's also known as **static type checking**.

**Static type checking** means your code is evaluated before it runs to ensure it works as expected.

That's also a limitation of TypeScript to keep in mind.

## Runtime and Compile Time

> TypeScript is JavaScript‚Äôs runtime with a compile-time type checker. ‚Äî [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)

- **Runtime** is when JavaScript code gets executed
- **Compile time** is when TypeScript code gets compiled to JavaScript code

**TypeScript only checks your code at compile time.**

This means you can't rely on TypeScript for checks in your code such as user input.

```ts:example.ts
const pokemon = []

function addPokemon(pokemonName: string) {
  pokemon.push(pokemonName)
}

// ['Pikachu'] ‚úÖ
addPokemon('Pikachu')

// Type 'number' not assignable to type 'string'. üö´
addPokemon(1)
```

Despite the TypeScript error, we can run the TypeScript code because type errors aren't syntax errors.

```js:example.js
const pokemon = []

function addPokemon(pokemonName) {
  pokemon.push(pokemonName)
}

// ['Pikachu'] ‚úÖ
addPokemon('Pikachu')

// oops! üò≥
addPokemon(1)
```

This is the compiled JavaScript code. TypeScript didn't betray us. We neglected to put checks and error validation in the code.

```ts:example.ts
const pokemon = []
const errors = []

function addPokemon(pokemonName: string) {
  if (!pokemonName || typeof pokemonName !== 'string') {
    // handle error
    errors.push('üí© Oops! You have to specify a Pokemon name.')
    return
  }

  pokemon.push(pokemonName)
}

// Type 'number' not assignable to type 'string'. üö´
addPokemon(1)
```

TypeScript doesn't change how JavaScript works.

## Gradual Adoption

So far we've seen we can reap the benefits of TypeScript without using TypeScript directly.

If you're on the fence about TypeScript but like using [JSDoc](https://jsdoc.app/) you can take advantage of TypeScript being built-in. You can use JSDoc for types and have self-documenting code that can outlive TypeScript.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/33-jsdoc.png"
  alt="JSDoc"
/>

You can read more about [JSDoc support](https://code.visualstudio.com/Docs/languages/javascript#_jsdoc-support) for VS Code and look at the examples.

That being said we can adjust how strict typechecking is when starting to use TypeScript so we don't get overwhelmed making adding types a gradual adoption.

If you decide on using TypeScript you don't have to rename everything at once but instead do it on a per-file basis.

## TypeScript Introduction Summary

Let's get a clear picture of TypeScript üì∏:

- TypeScript is a **static type checker**
- TypeScript is a **superset of JavaScript** (this means that any JavaScript program is also a valid TypeScript program)
- TypeScript **preserves the runtime behavior of JavaScript** (TypeScript doesn't change how JavaScript works)
- TypesScript **compiles to JavaScript**
- **Types are gone once it compiles to JavaScript** (the browser or Node doesn't understand TypeScript)
- Using TypeScript is a **gradual adoption**

## JavaScript Types

_"You don't need TypeScript, we have TypeScript at home"._

True _scholars_ üßê among you with _keen intellect_ might observe that JavaScript already has **primitive types**.

A **primitive type** is data that is not an object and has no methods.

JavaScript has **7 primitive types**:

- **string** (sequence of characters)
- **number** (floating point is the only number type)
- **bigint** (for huge numbers)
- **boolean** (logical data type with two values)
- **undefined** (assigned to variables that have just been declared)
- **symbol** (unique values)
- **null** (points to a nonexistent object or address)

Alongside those **primitive types** there are **primitive wrapper objects**:

- **String** (for the string primitive)
- **Number** (for the number primitive)
- **BigInt** (for the bigint primitive)
- **Boolean** (for the boolean primitive)
- **Symbol** (for the symbol primitive)

Let's clear up the difference between **primitive types** and **primitive wrapper objects** so you don't get confused if you should use the lowercase `string` or capitalized `String` as a type.

```js:example.js
// 'Pikachu'
const stringPrimitive = 'Pikachu'

// String { 'Pikachu' }
const stringObject = new String('Pikachu')
```

<Image
  height={250}
  width={589}
  src="/images/typescript-fundamentals/09-primitives.png"
  alt="Primitives"
/>

JavaScript converts **primitive types** to **primitive wrapper objects** behind the scenes so we can use their methods.

This is because methods like `.toUpperCase` extend the `String` object.

The reason we don't use **primitive wrapper objects** is because it's more work to get the value out of the object and we could get unexpected results if we pass an object to something expecting a primitive value.

That being said don't confuse the `new String` constructor with the function `String` that does type conversion.

```js:example.js
const number = '42'

const string = String(number) // '42'
```

As we've learned TypeScript doesn't save us at runtime, so we have to put checks in place.

```ts:example.ts
function isString(value: string): boolean {
  return typeof value === 'string' ? true : false
}

isString('Pikachu') // true ‚úÖ
isString(1) // false üö´
```

Why are we writing more code?

```js:example.js
const pokemon = []

function addPokemon(name, added) {
  pokemon.push({ name, added })
}

addPokemon('Pikachu', new Date())
```

Writing JavaScript we need to keep a lot of things in mind:

- Is the function callable?
- Does the function return anything?
- What are the arguments of function?
- What date format does the argument accept?

Even if we look at the implementation we don't know what date format we should pass, so we turn to documentation.

TypeScript helps us prevent making those mistakes in the first place by knowing we are accessing the correct properties and passing the correct arguments alongside code completion.

```ts:example.ts
const pokemon = []

function addPokemon(name: string, added: Date) {
  pokemon.push({ name, added })
}
```

In the example the argument `name` is of type `string` and argument `added` is of type `Date` which is just a custom built-in type.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/10-code-completion.png"
  alt="Code completion"
/>

This is extremely useful when dealing with a library API. The documentation lives in your editor.

```ts:example.ts
// Type 'string' is not assignable to parameter of type 'Date'. üö´
addPokemon('Pikachu', Date())
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/11-date-string.png"
  alt="Date string"
/>

The `Date` function returns a `string` but we have to pass the `new Date` constructor that returns an object. The type doesn't match so TypeScript complains that you can't assign `string` to `Date`.

```ts:example.ts
// [{ name: 'Pikachu', added: Date... }] ‚úÖ
addPokemon('Pikachu', new Date())
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/12-date-constructor.png"
  alt="Date constructor"
/>

Let's start learning about TypeScript and using it in practice.

## TypeScript Playground

To get started open the [TypeScript Playground](https://www.typescriptlang.org/play).

The playground is a great way of seeing the compiled JavaScript code and generated TypeScript types without having to set up anything and it's using the same [Monaco editor](https://microsoft.github.io/monaco-editor/) that powers VS Code, so you should feel at home.

<Image
  height={843}
  width={1300}
  src="/images/typescript-fundamentals/34-typescript-playground.png"
  alt="TypeScript Playground"
/>

The right side of the editor has some useful tabs:

- **.JS** shows the compiled JavaScript output (the default target is ES2017 which is adjustable from the **TS Config** tab)
- **.D.TS** has the generated TypeScript types
- **Errors** is like the error logs in your console
- **Logs** show the output of your code

You can press <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to run the code in the playground. Another tip I have is to include `console.clear()` at the top so your logs stay readable.

If you can't see the right sidebar press the arrow icon at the top right.

## Type Inference

TypeScript can infer types to provide type information.

```ts:playground.ts
let pokemon = 'Pikachu'

pokemon = 'Charizard'

// 'CHARIZARD' ‚úÖ
pokemon.toUpperCase()

// Type 'number' is not assignable to type 'string'. üö´
pokemon = 1

// This expression is not callable. üö´
pokemon()
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/DYUwLgBADg9g1iAtjAdhAvBA5ABQJZwCGAxgBYCuWAUFbAsmplgMKmEBOeAXhwCbVUA9IOzMAEgEEASgEkAWtIAiWCIFByWvCSoAdGBgBVKFBDtmhAM4gAFAEoawiABUAnsewpyiAEYmVecxAoMJAW5ngA5iiEXqAQenGuINjmYJwo4VjaEIC8G4DVexr0qBgQAIz2Io6k-hAgAB5Q7CDmYUXVQZDEhMDA0aBZeQVaKLZAA"
  load={false}
/>

How great is this instant feedback in your editor?

TypeScript can also infer the return type from a function. If we're not returning anything it's `void`.

```ts:playground.ts
function returnPokemon() {
  // return string
  return 'Pikachu'
}

function logPokemon() {
  // we don't return anything
  console.log('Pikachu')
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAJwKZRMsAFOBrVAWwQAoBKRAbwChEV1MkBybGPAQwgAsQnqBfatVCRYCRABs4Ac1wFiYclVqIICAM5wJqAHRTpJFm048mZAUA"
  load={false}
/>

It's encouraged to let TypeScript infer what it can but you can also be explicit.

```ts:playground.ts
function returnPokemon(): string {
  // return string
  return 'Pikachu'
}

function logPokemon(): void {
  // we don't return anything
  console.log('Pikachu')
}
```

In the next example we're looking at the return type of a fetch API request.

```ts:playground.ts
async function getPokemon(name: string) {
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)
  const pokemon = await response.json()
  return pokemon
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/IYZwngdgxgBAZgV2gFwJYHsIwOYFNkAK6A1rgLaYAUEwZuAXDCMgE6oTYCUMA3gFAwYUTMxgtcIAA4jcMALwxgAd2Cpk8fFAAWlAAZbkySSHoB6U9NLBJqAHTDT11KYBuAJgslymUwBIeNHQAvrqcAkIi6pbeWArKquriUjK2AFYgVGGC4sgILFjRFBB8QUA"
  load={false}
/>

If you hover over `getPokemon` you can see TypeScript infered the return type as `Promise<any>`.

`any` is an escape hatch when we don't know what the type is.

```ts:playground.ts
async function getPokemon(name: string): Promise<{ id: number, name: string }> {
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)
  const pokemon = await response.json()
  return pokemon
}
```

Here we're more explicit about the return type with using the object type `{ id: number, name: string }`.

```ts:playground.ts
async function getPokemon(name: string): Promise<{ id: number, name: string }> {
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)
  const pokemon = await response.json()
  return pokemon
}

async function logPokemon() {
  const pikachu = await getPokemon('pikachu')
  console.log({ id: pikachu.id, name: pikachu.name })
}

logPokemon()
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/IYZwngdgxgBAZgV2gFwJYHsIwOYFNkAK6A1rgLaYAUEwZuAXDCMgE6oTYCUjBL6ZqELgA8AbxioAJowgIyAI1wsANDBp1GzNhxgBfAHwxRAKBgwomZjBa4QAB0u4YAXhjAA7sFTJ4+KAAtKAAN-ZGQ7EHoAeiiHUmA7VAA6CyiE1CiANwAmWJJyTCiAElF1XF0gzlNzSx84gqxXDy8fG3tHJIArECoqsxtkBBYseooIY11jY1BIWEQUDCwAG3RsIlIxyk4jaosIK0TiYACEFzdPbxx8dYbKAHJD4-8EO76a-fQl3CSV7EpxKSMR4nJJSVRlIGoI4gsp6KqTYy-G6bThAA"
  load={false}
/>

Thanks to this slight change we get code completion for the `pikachu` object since TypeScript knows the type. It's magic. ü™Ñ

We're going to go in-depth later and explore how to make this more organized by using other TypeScript features.

## Type Annotations

**Type annotations** are an explicit way of specifying a type.

```ts:example.ts
const pokemon: string = 'Pikachu'
```

## Primitive Types

TypeScript has the same basic **primitive types**.

```ts:example.ts
const pokemon: string = 'Pikachu'
const hp: number = 35
const caught: boolean = true
```

## TypeScript Types

TypeScript extends the list of types:

- **any**
- **unknown**
- **void**
- **never**

## any

Type `any` is a special type:

- You can use it as an escape hatch when you don't want something to cause typechecking errors
- It represents all possible values
- You get no type checking

```ts:playground.ts
const apiResponse: any = {
  data: []
}

// we don't get any warning üò±
apiResponse.doesntExist
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhgBwJYCUCmEHgmgXPMATxgF4YBvAKBhgBM4o58BtAXUoF9LKB6HmAO5o64AOSwA5mlhwiguACcwSMBJiBeDcCMe5USoMWSGgB0tEBjBQAogA8k0GEA"
  load={false}
/>

Using `any` is useful when:

- You're working with a library that lacks types
- You have a complex API response you don't want to type
- The API of the code you're writing could change

If you want to focus on writing code I suggest instead of using `any` everywhere to include `// @ts-nocheck` at the top of your file. After you're done writing code turn typechecking back on.

**Don't let your editor bully you.**

Be conservative when using `any` because it defeats the purpose of using TypeScript.

## unknown

Type `unknown` is the type-safe version of `any`:

- You can assign any value to `unknown` but you can't do whatever you want
- You must perform checks before you can use a value
- You can't access any properties on values
- `unknown` can only be assigned to `unknown` and `any`

```ts:example.ts
const apiResponse: unknown = {
  data: []
}

// assignable to `any` ‚úÖ
const anyType: any = apiResponse

// assignable to `unknown` ‚úÖ
const unknownType: unknown = apiResponse

// 'unknown' not assignable to type '{ data: []; }'. üö´
const otherType: { data: [] } = apiResponse

// we have to use checks to narrow down the type
if (apiResponse && typeof apiResponse === 'object') {
  // Property 'data' does not exist on type 'object'. üö´
  apiResponse.data
}
```

We narrowed down what the type of `apiResponse` is, yet we can't access the `data` property since it's `unknown`.

To solve the problem we have to use **type assertion** that let's TypeScript know we know the type.

```ts:playground.ts
if (apiResponse && typeof apiResponse === 'object') {
    const response = apiResponse as { data: [] }
    response.data // no warning ‚úÖ
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhgBwJYCUCmEHgmgXDAVzAGswQB3MGAXhgG8AoGGAEzijnwG0BdBgXwYMA9MPgQISAOZg4AIwA2aGFBAwABnDABPdTECg5A1CRYW7QBVtCPPB014ydJmxoho8ZJnylKteqKkFGB6hsbQhCRklJbW+AFRVLSIqBhYkK4iYgDk8UFZMGSmEtKyisqqKlbKWXSs7JwwvADcMPxZAHQwgLwbgNV7RtiwIFAAFmgATjE2tWwc3Dyt9slOaThCSABmMAAUS6kuMABkB5XWIJu7zuk01LRZIHIAVmjAUFkAlPRMzDBhsGN7VySjgBOHE9Dqs0a80E3xg-0uOHaMzgMHcZBg5DgYzASDAUgMAiAA"
  load={false}
/>

We're going to learn about **type assertion** later.

`unknown` is safer to use than `any` when we don't know the function argument.

```ts:playground.ts
function prettyPrint(input: unknown): string {
  if (Array.isArray(input)) {
    // we can run each value through prettyPrint again
    return `[${input.map(prettyPrint).join(', ')}]`
  }

  if (typeof input === 'string') {
    return input
  }

  if (typeof input === 'number') {
    return String(input)
  }

  return '...'
}

prettyPrint(['Bulbasaur', 'Charmander', 'Squirtle', 1, {}]))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABABwE4FMpQJ4AVUxhQAUhyIUAXIuANZhwDuYAlNQM5QFgDmiA3gChEIxDGCJiAQVSoAhtgB0MdjPnZSYclBYsBw0YYxQQqJAAMA2gBJ+ZCooC2c5MTSYc+QjsUArOITEAOQANIhBLAC+ALrmBiKRgvFiEsQ4yOhwEvZQiAC8BeGc3DwR+oZGmKZIOcmJyeKS6ZnZWhT5hUFgII4ARuioZUIVosbViADKXIQ8mtosdUmVJmbhiutBgvUQCOxwADboivtws8nuWHjcJJZBAEIg+71y7HKmoeEAwgAWcqjOYAAJgMPkEJgBHEAwVBQQ4fACMYX4MQWLCAA"
  load={false}
/>

We can use `unknown` to describe a function that returns an unknown value.

```ts:playground.ts
const json = `
  {
    "id": 1,
    "name": "Pikachu"
  }
`

function safeParse(value: string): unknown {
    return JSON.parse(value)
}

const obj = safeParse(json) // safe ‚úÖ
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAVhcMC8MAGAoG2YG8s6EBEAlgCZEBcMAjADQGHZFgCGAtgKZUxEAKJANatgACwCuRRjAC+GTBgBm4sMCgkkEVos59WAJwicAFADdWAG3Gdq0fSTABzAJTUVgsCADuYPNP2cUOL6vgBSAMoA8gByAHQADgZGZpbWzhhyGKCQsCAARnAoMFo6eoYmCODOMAD0NcXanDCAoORAA"
  load={false}
/>

If we didn't use `unknown` the infered return type would be `any` meaning you could do whatever you want with `obj`.

If you're confused when you'd use `any` or `unknown` it's fine. You should avoid using them if possible.

## void

Type `void` is the absence of having any type.

There's no point assigning `void` to a variable since only `undefined` is assignable to `void`.

```ts:example.ts
let pokemon: void

pokemon = undefined

// Type 'string' is not assignable to type 'void'. üö´
pokemon = 'Pikachu'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/DYUwLgBADg9g1iAtjAdgLggNxgSwCYBQBsCyKEAvBAK4p4gBmOKIhBA9OxACoCeUICAHIAzmABOzAOZCIOERBQxIAQxEicUlCoBGoCGBgH+godnxCAdBEC8G4Gq94vCSpKwgAo44KgMYALakJAA"
  load={false}
/>

Type `void` is used on functions that don't return anything.

```ts:example.ts
function logPokemon(pokemon: string): void {
  console.log(pokemon)
}

logPokemon('Pikachu')
```

Let's learn why type `void` is useful when used in a `forEach` implementation.

```ts:playground.ts
function forEach(arr: any[], callback: (arg: any, index?: number) => void): void {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i)
  }
}

forEach(['Bulbasaur', 'Charmander', 'Squirtle'], (pokemon) => console.log(pokemon))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABMOAnAogQwgCwBSaqoBcimYAngNoC6ANIhJgDbMBG2A1qQagOalyFBjDAATAKYAPAPykwIALZsJqAJSIAvAD5EANzgwxa0gaOIA3gChEyNIjzMJURDC2IADAG5XiADxkRAB0TmB8UDg+MADU0RrWtrZMrBwQnLyoVDD0rmo2iAC+VkVWKBjY+FQA5ABCIOyYAM6YIKhVDFUAwjiEiuSSbR0AygCOIDCoUE5VOXgADnCcEooIGjqMCI1wTiFwfPOLy6tqQA"
  load={false}
/>

Because we used type `void` as the return type for `forEach` we're saying the return value isn't going to be used. This let's it be called with a callback that returns any value.

Using the return type `void` explicity can save us from returning a value on accident during refactor.

```ts:playground.ts
function logPokemon(pokemonList: string[]): void {
  pokemonList.forEach(pokemon => {
    // ...
    return pokemon
  })
}

function logPokemonRefactor(pokemonList: string[]): void {
  for (const pokemon of pokemonList) {
    // ...
    // Type 'string' is not assignable to type 'void'. üö´
    return pokemon
  }
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAFAA44EIAyMAzlAFyJ0BOMYaA2gLoCUjAbnBgATRAG8AUImmIyeQmGp0AdMDjMAogEMIAC1LkFiALwA+cVJlWA9NcTKHlq9Oa4oIZkjkUwTxAF8eCX8JCVBIWAQUdCx5BAAlXGAdKHUDOMVaBiYoVnZuPkRBEQsrNWZEIggEOllDKLhgOoylKB5S52lbe0dOrrsAFQBPElxEAHIWNk4uccRaRDA4KEQtGhoYNDAtACNkMdTEKBGx8eLhceVEQF4NwGq9vytXd09mnz8Q-yA"
  load={false}
/>

## never

Type `never` represents values that never occur:

- `never` can't have a value
- Used when there's no reachable end point like a while loop or error exception
- Variables get the type `never` when narrowed by type guards to remove possibilities (one great example are props passed to a component where we can say if one type of prop gets passed other can't)

```ts:playground.ts
function infiniteLoop(): never {
  while (true) {
    // do something
  }
}

function error(message: string): never {
  throw new Error(message)
}

function timeout(ms: number): Promise<never> {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error('‚åõ Timed out.')), ms)
  })
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABDMwUygUwDJzgBwAoBKALkTEwDdMAnRAbwChFEB3ACxgBtNFCotEJmKMWrRAHpJiACZxEAZzgBbTFC5gA5uIC+TfU1CRYCRHVpxahNYsUBDLZnKLBKLWQrU6Y1hstsXoEAorSW1rYOTsQGTEbg0PBIsGpwIFA2iuRgICoARnSeAAqWKjCKmAA8lDS0AHy+iLTqILRIlIElquWYhIQA+gA0TZgAVpjQogC8DcwSSuoAKjCp6X3TDc3j0IQdiKHhhADkgNjEiMtqsohpUAB0R8TEwyqKMay6MfpAA"
  load={false}
/>

Type `unknown` can be used together with **type narrowing** to ensure we have a check for each Pokemon type.

```ts:playground.ts
function getPokemonByType(
  pokemonType: 'fire' | 'water' | 'electric'
) {
  // type is 'fire' | 'water' | 'electric'
  if (pokemonType === 'fire') {
    return 'üî• fire Pokemon'
  }

  // we narrow it down to 'water' | 'electric'
  if (pokemonType === 'water') {
    return 'üåÄ water Pokemon'
  }

  // only ‚ö° 'electric' is left
  pokemonType

  // remainingPokemonTypes can't have any value because
  // pokemonType is 'electric' üö´
  const remainingPokemonTypes: never = pokemonType


  return remainingPokemonTypes
}

getPokemonByType('electric')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAcwKZQApwNaoLYIBCAngCrEAOqAFAFCKIU74LlUBciA5MDAE6ouiAD7cA7gEMoqPkNFdUAG1TQ+MCF1oBKRAG96DRAHojiKJVSIYAZ268Bc8VJmOFy1es2GrwRNSa4BGBslgC84Xb8gjr63t4CUCB8SFyAvBuApLuI9pZYgQhehgC+tAYMJohilmASfHxwYlZQiAAm9UhQcE7SsiLcSipQahqlPn4BLMEWiOGhXS4xI-HoSSmAPBuAAPsVznyIuRMFDMUj5QiKxIiAhWR97oOeVrbKwFAj40EhJd7lAngSMGB-yD2bwstggEjAXCaAAsJAA3Szg86wiSKECWABGKgkIGsqGOplerCmNmuAyGQlSgGq9kYQBDWJrfX7-MCA5jAqjWThgVDwnazQmTKglEYJFaIRl-AFAokc2hHNCYNlEMgWahuMmeLRAA"
  load={false}
/>

Because of this check we know that `getPokemonByType` is missing a check for the `electric` type.

We haven't yet learned about some of the types in the examples. We're not glossing over them. We're going to cover each later.

## Array Types

There's two equivalent ways to specify an **array type** in TypeScript.

To specify an **array type** you can use the generics `Array<Type>` syntax or the `type[]` syntax.

```ts:playground.ts
const pokemonGenerics: Array<string> = ['Bulbasaur', 'Charmander', 'Squirtle']

const pokemonBrackets: string[] = ['Bulbasaur', 'Charmander', 'Squirtle']
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBADiA1gUwLbgOLLMgTgS2AgC4YBBXXAQwE8AeaAsAcwD4YBeGAbQHIAhAK4AbAEZUIVQbl4AaGLwDCACyq5UVMABM8chQGUAjoPy4ow5LwC6AKBuhIsBCnRh+1YCigkYjfC24rTh4BEXFJaT0lVXVNHRl5XiMTMwtrGyA"
  load={false}
/>

I prefer the `any[]` syntax because it's less to type.

## Function Types

You can specify the input and output type of values.

```ts:playground.ts
const pokemon: string[] = []

function addPokemon(name: string): string[] {
    pokemon.push(name)
    return pokemon
}

addPokemon('Pikachu')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBADiA1gUwLbgFw2gJwJZgDmA2gLowC8MZAUDQGYCuYwUe4MAhgCbcAKSNOAAUYTqmRZcBQgEopUfETIwA3jRib4g9GAB0cRhAAWo8clkatOZFEY4w2lLpoBfOj346RAcj55ETmBjRh9ZIA"
  load={false}
/>

We explicitly typed `pokemon` as `string[]`. If TypeScript can't infer the type it would use `any` by default, or in this case it would be `any[]`.

Anonymous functions are slightly different in the way they take advantage of **contextual typing** but adding type annotations is the same.

```ts:playground.ts
const pokemon: string[] = []

const addPokemon = (name: string): string[] => {
    pokemon.push(name)
    return pokemon
}

addPokemon('Pikachu')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBADiA1gUwLbgFw2gJwJZgDmA2gLowC8MZAUDaJLAIYAmLACkmuJTABRgmqZFlwFCASlFR8RMpQB8MAN40Y6+F3RgAdHACuEABYChyCWo05kUfTjCaU2mgF86rDlvB8A5OzyITMBG+j4SQA"
  load={false}
/>

TypeScript uses **contextual typing** to figure out the type of the argument based on how it's used.

```ts:playground.ts
const pokemonList = ['Bulbasaur', 'Charmander', 'Squirtle']

// 'Bulbasaur', 'Charmander', 'Squirtle'
pokemonList.forEach(pokemon => console.log(pokemon))
```

TypeScript infered `pokemonList` is of type `string[]`. Because of this inside `forEach` it knows the individual `pokemon` type should be of type `string`.

```ts:playground.ts
// being explicit here is ok ‚úÖ
const pokemonList: string[] = ['Bulbasaur', 'Charmander', 'Squirtle']

// don't do this üö´
pokemonList.forEach((pokemon: string) => console.log(pokemon))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/PTAECMFMEsDsHNSQB4AcA20DG0AuoALSAJ0lGgGdQB7Aa1EFByAKC2tgv1TsgFs2AZSrgBcoDsTjwA2gF1QAXlBSA5ACEArunABDCtvXFlAGlDKAwgW3Ee22ABMSx0wGUAjuujFc6SMplMmEFA7NmV8ENBcAkpQQF4NwGq9pi5aXgEhADoAM2piAFFtLAIACiLk1NhRcUkASgUAPlBWdmofdPRqeFLuPlhq6qA"
  load={false}
/>

Knowing about **contextual typing** you understand what things you don't have to type.

Function arguments can be made optional by using the `?` operator.

```ts:playground.ts
function logPokemon(name: string, hp?: number) {
  console.log({ name, hp })
}

logPokemon('Pikachu') // { name: 'Pikachu', hp: undefined }
logPokemon('Pikachu', 35) // { name: 'Pikachu', hp: 35 }
```

## Function Overloads

**Function overloading** is the ability to create multiple functions of the same name with different implementations. Which implementation gets used depends on the arguments we pass in.

In JavaScript there is no **function overloading** because we can pass any number of parameters of any type we then perform checks on inside the functions.

```js:example.js
function logPokemon(arg1, arg2) {
  if (typeof arg1 === 'string' && typeof arg2 === 'number') {
    console.log(`${arg1} has ${arg2} HP.`)
  }

  if (typeof arg1 === 'object') {
    const { name, hp } = arg1
    console.log(`${name} has ${hp} HP.`)
  }
}

// 'Pikachu has 35 HP.' ‚úÖ
logPokemon('Pikachu', 35)

// 'Pikachu has 35 HP.' ‚úÖ
logPokemon({ name: 'Pikachu', hp: 35 })
```

TypeScript has **overload signatures** that let you call a function in different ways.

```ts:playground.ts
interface Pokemon {
    name: string
    hp: number
}

function logPokemon(name: string, hp: number): void
function logPokemon(pokemonObject: Pokemon): void

function logPokemon(arg1: unknown, arg2?: unknown): void {
    // matches the first overload signature
  if (typeof arg1 === 'string' && typeof arg2 === 'number') {
    // arg1 is `name` and arg2 is `hp`
    console.log(`${arg1} has ${arg2} HP.`)
  }

  // matches the second overload signature
  if (typeof arg1 === 'object') {
    // since it's an object we can assert the type to be Pokemon
    const { name, hp } = arg1 as Pokemon

    // log the destructured values
    console.log(`${name} has ${hp} HP.`)
  }
}

// 'Pikachu has 35 HP.' ‚úÖ
logPokemon('Pikachu', 35)

// 'Pikachu has 35 HP.' ‚úÖ
logPokemon({ name: 'Pikachu', hp: 35 })
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26TIDeAUMmciHDhAFzIDOYUoA5qeQBYAOdIArjgBG0YgF9ixGHxAIwwfMgA26Fhmx4QACkrU6jZiBYAaZN14DhUAJR0AbumAATSdNnyCy1Vlz5NXbxoA8oIAVhCydGo+IDbI9k4SUjJyCp5RGppwUCwAjHTSmCDoAO4gJlksAEwA-PkghSUxdg6OROzkAPQdyDhwYAgcEPTIYIPIMMBQjMjottDKcK30wCyUYHxQKOTtyMAwyJpgAJ5cEOj7FTnIALy3yADk+qz3yABkryMnZxfZlTd3934Qmg9ysbXIEOQXWQl12wwABjoIPCYSBWhU-sAEdx4TsIQh8PR0IoIAA6TyaeEAEkIl1EpjgwxpGPpAAlUKT4VYduJkDtob1+oNhqMUPRwvhWrN5uhFgwVmsNhAdnsDsdTucYdkrrdrg90KFwmBQeDIWRocsZChgMbhnACAawrJkMUUAh7TD6OKoGARmN1SgwOhkMI0AF8HjyASQNNCBQqBATNxkPS9bDGWH1BHI+bup4-ShHEMmHxZErWrY4Io+EMc8ho0SSeSVJSaUj6RwMzTuGyOVyeXzxMRofdUMBMIgOHwGcMAMwAVmQ7NJL0AoOTENLhrSj8eTvj3EwL7nD7o7icDaedueL5drjcqdK+ONIuhnvcH0w8ZALlPcoA"
  load={false}
/>

Let's break it down into steps:

- We wrote two **overload signatures**
- The first **overload signature** accepts `name` and `hp`
- The second **overload signature** accepts a `pokemonObject`
- After that we wrote a **function implementation** with a **compatible signature** where the second `arg2` argument is optional since the minimal amount of arguments is one
- If `arg1` is `string` and `arg2` is `number` we know that's the first signature
- If `arg1` is an `object` we know it's the Pokemon object, so we can use a type assertion and destructure the `name` and `hp` values from it

<Image
  height={267}
  width={712}
  src="/images/typescript-fundamentals/14-overload-signature.png"
  alt="Overload signature"
/>

<Image
  height={121}
  width={673}
  src="/images/typescript-fundamentals/15-overload-signature.png"
  alt="Overload signature"
/>

## Object Types

The **object type** is like a regular object in JavaScript.

If you hover over `pokemon` TypeScript already knows it's shape.

```ts:playground.ts
// infered type
const pokemonInferedType = {
  name: 'Pikachu'
}

// explicit type
const pokemonExplicitType: { name: string } = {
  name: 'Pikachu'
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/PTAEEsDsDMFMCdYBNQBcCeAHWAoAxgPaQDOqomBA1rALZECSMCyAKlrKALygDeOooSAEMasAFygA5AAVwlIXgAWAV0k4AvjhwhQsAB6YANuDzgyGbPiKlyVWkQCiB46dRtsEnoJHjQpeFAA5qDqXLz83qISMnIKKmrqQA"
  load={false}
/>

In the next examples we can see how TypeScript treats missing, optional, and extra object properties.

```ts:playground.ts
// Property 'id' is missing in type '{ name: string; }' but
// required in type '{ id: number; name: string; }'. üö´
const pokemonMissingProperty: { id: number, name: string } = {
  name: 'Pikachu'
}
```

```ts:playground.ts
// `id` is optional ‚úÖ
const pokemonOptionalArgument: { id?: number, name: string } = {
  name: 'Pikachu'
}
```

```ts:playground.ts
// Object literal may only specify known properties. üö´
const pokemonExtraProperty: { id?: number, name: string } = {
  id: 1,
  name: 'Pikachu',
  pokemonType: 'electric'
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/PTAEAUCcHsAcFNIBcCeoDkBLAJu0mBnUAW0IMwDsBzfC0VBDAb1AoENj4AuUApSSlQDcoAL54ARgFckAKBChI8AI5TMS7LXopG6Fjh4UpxCYhHtOPPgOojxAOlCBeDcDVe7IDG0Cn1CxoAa3hiLwBZMkEoOERUHn1sQ2NTSAAaVg5uXn5BMVAAXlAmWVBitMsMcEx-NncACyl0WVFZeTAAAxxW-CI4JEwvNgAbZ0BZHY8vHz9A4IoAeVhe-oGAQUgqY3gKJFj8bAB+BJNEVIsM62zRPIKikpOedAqq2vrG5oUZiQAreHckUAHMJCIQYkNhoLwDNAEBDuTAAMzQ-go0AA7nRYDAEMhMPACI5XGNvL9JkEvABRAAe-DYkUxMQKO32rESR1Kpyy1By+UKJR2PAAjMlrsVbuVKtU6uhBTzidMACo6DLoeADb5ZdwNURAA"
  load={false}
/>

We're going to learn ways to abstract these types to make it more readable.

## Union Types

A **union type** is a type made from at least two types and represents any values of those types.

```ts:playground.ts
function logPokemon(pokemon: string[] | string) {
  console.log(pokemon)
}

// ['Bulbasaur', 'Charmander', 'Squirtle']
logPokemon(['Bulbasaur', 'Charmander', 'Squirtle'])

// Pikachu
logPokemon('Pikachu')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAFAA44EIBciAzlAE4xhoDaAuogD60NNoCUiAN4AoROMQQENOMlwA6VGlLlCYfiIC+IkQHpdiFgHIAQiGQAjAIY0rIekYA0iIwGEAFlfr4rYACa4Ds5GAMoAjiAw9FByRmwiSlh4akTGZpY2dkEuHl4+-oFOLuGR0bFsGnoGGDDYVhDuIAnoSRRgREY1dQ0gRvxAA"
  load={false}
/>

The `pokemon` argument can only be an array of Pokemon of type `string[]` or a single Pokemon of type `string`.

You can only do things with the union type that every member supports meaning that you can't just use a `string` method without checks because you said to TypeScript it could be `string[] | string`.

```ts:playground.ts
function logPokemon(pokemon: string[] | string) {
  // Property 'toUpperCase' does not exist on type 'string[]'. üö´
  console.log(pokemon.toUpperCase())
}

logPokemon(['Bulbasaur', 'Charmander', 'Squirtle']) // üö´
logPokemon('Pikachu') // üö´
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAFAA44EIBciAzlAE4xhoDaAuogD60NNoCUiAN4AoRIgD0ExBnpwSuelACeiAORQ4AVRIL6AYQCGNXGsQATOLhqIwcKIlwAPGHUQJEKherqNm7NQA6REBeDcBqvbFECAQaOGRcQNQ0UnJCMEDNHT0jEyJ+fhEAXxERJKw8NKIWNQAhEGQAI2NDEHo1ABp1fQALQ3p8QzBzRQ71AGUARxAYJXi1NgKy1OI1DBhsQwhukDV+IA"
  load={false}
/>

Instead we have to put checks in place to narrow down the type so TypeScript knows the exact type.

```ts:playground.ts
function logPokemon(pokemon: string[] | string) {
  if (Array.isArray(pokemon)) {
    // `pokemon` can only be an array
    console.log(pokemon.map(pokemon => pokemon.toUpperCase()))
  }

  if (typeof pokemon === 'string') {
    // `pokemon` can only be string
    console.log(pokemon.toUpperCase())
  }
}

// ['BULBASAUR', 'CHARMANDER', 'SQUIRTLE']
logPokemon(['Bulbasaur', 'Charmander', 'Squirtle'])

// PIKACHU
logPokemon('Pikachu')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAFAA44EIBciAzlAE4xhoDaAuogD60NNoCUiAN4AoROMQxgiIgEF69AIYBPAHQwa8pctLlCYfoNESTiAPRnEAAzJ59VxBEVIEyZYgBGuRM58KVYqbiEAg0cMi4qqhounYIqviKJLEUSAC8AHyItqmqUHAAqiQkuPQAwoo0uESG-IHiAL4i9ZLSRFDKJXDSOfqIaQOIAOR0jMxDRi0mFta9CA5OLmBunt6jfFMSIWBhEVHoKfp5hcWlFVU1dSZNTSIzLEMAQgUAMo+yAMqyBQBKQwA0wzKAAlZD8ALKyAByABEAKJ-QFDD4ARQKAEkfgAVF5woZsETRLBxMBEB6PEDIDyVRQgegAoEAC0U9ESYAAJqUGciAI4gGD0KARfF1O6WDDogDSshBBUJ6GJqSIQwwMGwiggjJAEyAA"
  load={false}
/>

The second `if...else` statement is not required since if `pokemon` isn't of type `string[]` it can only be `string`.

In situations where the union members like `string[]` and `string` overlap and share the same methods such as `slice` you don't have to narrow the type.

```ts:playground.ts
function logPokemon(pokemon: string[] | string) {
  // works for both types ‚úÖ
  console.log(pokemon.slice(0, 1))
}

// ['Bulbasaur']
logPokemon(['Bulbasaur', 'Charmander', 'Squirtle'])

// 'P'
logPokemon('Pikachu')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAFAA44EIBciAzlAE4xhoDaAuogD60NNoCUiAN4AoROMQB6SYgDucethqJgCxACM4UABaIoATxK5lgUHIxEiAhpxkuAHSo0pcoTB2ayGBFxEADABpEAEZ+fhEAXxERaUQWAHIAIRBkdQBDGlSQeji2EUcsPFcieKSU9MzswLiAYW1U+nxUsAATXErEOIBlAEcQGHooWxyw6Jk4jDi89AKKMCJxmGxUiG0QOP4gA"
  load={false}
/>

## Discriminated Unions

A **discriminated union** is the result of **narrowing** the members of the union that have the same **literal type**.

For example we can use a **type guard** to narrow the Pokemon type to `'fire' | 'water'` but we can also provide TypeScript with hints so it knows all of the possible types.

Let's _switch_ ü§≠ it up for fun:

```ts:playground.ts
interface Pokemon {
  flamethrower?: () => void
  whirlpool?: () => void
  pokemonType: 'fire' | 'water'
}

function pokemonAttack(pokemon: Pokemon) {
  switch (pokemon.pokemonType) {
    case 'fire':
      // Cannot invoke an object which is possibly 'undefined'. üö´
      pokemon.flamethrower()
      break
    case 'water':
      // Cannot invoke an object which is possibly 'undefined'. üö´
      pokemon.whirlpool()
      break
  }
}

// üî• 'Flamethrower'
pokemonAttack({
  pokemonType: 'fire',
  flamethrower: () => console.log('üî• Flamethrower')
})

// üåÄ 'Whirlpool'
pokemonAttack({
  pokemonType: 'water',
  whirlpool: () => console.log('üåÄ Whirlpool')
})
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26TIDeAUMmcjADZw4RgAWU6A7tAPwBcyAFAJTIBeAHzIAbumAATUuWb1gUSgAd06Spx79hYidPLIV2PCAAqATyUQuAchgKI15AB9k15nEhRrxAL7FiMACuIAhgwPgGWLj4AIJgYIiY3IbRIFwYRvj8JPoAzszAYAj0PCnGAHRl+OaW2TL6ZAhwuSi29tYc9Q36APQ9yADCcCAg6GDIoOLYyMPI6ABGAFYQochywMUTuZG5ucDzlGauwZIQdiAQktblyIC8G4DVe13dZFUg5VQ0dIws0HxPz-MoBA4Jh-o1mq13J4OmCGn1BsNRuNJlEZgQFstVutNsBtipdvtDscQKdzpdrndHs8Gq9yutFCo1H9qfpAcDQfo-H5iPDboBSXdcADFqLQGExWF5iK84gkEEkcuRXjUrK47EDrAAaLofUXfCVcPiCEQIfC5NQQcqUdAAc241n5yGFnzFPy8vF87p5-UAPBuAAH3XAB1eQM1SUbzS+KJbgKl5RYzKmxQ6Carr05Shg1aY2m82Wm12v3IIMKdNqazuny8IA"
  load={false}
/>

The type-checker can't determine if `flamethrower` or `whirpool` is present based on the `pokemonType` property because they could not exist as they're optional and we can't require both because that would defeat the purpose.

To solve this problem we have to be more explicit and separate the arguments so TypeScript can be sure of the type.

```ts:playground.ts
interface Fire {
  flamethrower: () => void
  pokemonType: 'fire'
}

interface Water {
  whirlpool: () => void
  pokemonType: 'water'
}

type Pokemon = Fire | Water

function pokemonAttack(pokemon: Pokemon) {
  switch (pokemon.pokemonType) {
    case 'fire':
      pokemon.flamethrower()
      break
    case 'water':
      pokemon.whirlpool()
      break
  }
}

// üî• 'Flamethrower'
pokemonAttack({
  pokemonType: 'fire',
  flamethrower: () => console.log('üî• Flamethrower')
})

// üåÄ 'Whirlpool'
pokemonAttack({
  pokemonType: 'water',
  whirlpool: () => console.log('üåÄ Whirlpool')
})
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgGLCig3gKGf5GAGzgFsIwALKAewHdoAuZACgEpkBeAPmQDcawACZ4CABxoBrCKRogAKgE8xEZgHIYGCGpwBfHDlCRYiFAHU4x5LgLI6lDEQk0izdl14Dho-BOmyFZVVkNTpLaB19HDAg5AAFKRk5LjQtZAAfZAtjAxgAVxAEMGBkvySQAEEwMERJFjKA5gT-OQ4bAgBnOmAwBEpWBrkAOkHAlTafW2QEOA6UDS01Rkmp8USAoeIyCmp6aHYV1eQAI0w4SUP8GbmQsOMly6nRoftHZyIDo6nTiHPJ-SiAHpAchALwbgFJdkKoEjkKi0BhQHSjKo1BB1dqjJQqdSaTBqAA0oi2sN2CLcHB40zkHRcECGRBoAHMWGoIWgYTt4RE2HoeThgchADwbgAB9kJmBxQJw0FxI9ZyFG1FgYuVjYKhcKIwn4V6S97kjxUkA0oh0hnMtQirISqUynm6NhAA"
  load={false}
/>

By the use of a type guard style check `==`, `===`, `!=`, `!==` or `switch` on the discriminant property `pokemonType` TypeScript can do **type narrowing** based on the **literal type**.

This also helps us catch mistakes if something passed through the `switch` clauses that shouldn't have.

## Type Aliases

So far we've been using types directly using **type annotations**. This is hard to read and not reusable.

A **type alias** is as the name suggests ‚Äî just an alias for a type.

Just how there's people with different _types_. ü§≠

You should already be familiar with the **object type** syntax.

```ts:playground.ts
type Pokemon = { id: number, name: string, pokemonType: string }

const pokemon: Pokemon[] = [{
  id: 1,
  name: 'Pikachu',
  pokemonType: 'electric'
}]

// { 'id': 1, 'name': 'Pikachu', 'pokemonType': 'electric' }
pokemon.forEach(pokemon => console.log(pokemon))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/C4TwDgpgBACg9gawgWzgOygXigbygSwBMAuKNAV2QCMIAnAGjIENkJSBnYW-NAc0bCIU6ACrg2UTtz5QAvgCh5AY3ScogpKjSl4m9AG0Aulij6c8qJYIkoARnoWraFhIDkMfAiZKAFuVcOVupCWmKQpK4QADYQSlz4Sq7ysoaKAPRpuFCuRK6k9tnOrHnZHl6+-oyuGsJoYRAlkTFx3Ily8jVaAHQAZnC0AKLePgAUnehYAHxQKmjscDFdUXC8YyHoAJQbQA"
  load={false}
/>

Instead of writing `Pokemon[]` where `[]` indicates to TypeScript it's an array of Pokemon we can say `{ id: number, name: string, type: string }[]` which is equivalent.

```ts:playground.ts
type Pokemon = { id: number, name: string, pokemonType: string }[]

const pokemon: Pokemon = [{
  id: 1,
  name: 'Pikachu',
  pokemonType: 'electric'
}]

// { 'id': 1, 'name': 'Pikachu', 'pokemonType': 'electric' }
pokemon.forEach(pokemon => console.log(pokemon))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/C4TwDgpgBACg9gawgWzgOygXigbygSwBMAuKNAV2QCMIAnAGjIENkJSBnYW-NAc0bCIU6ACrg2UTtz5QAvgG0AugChlAY3ScogpKjSl4u9FijycyqJYIkoARnoWraFhIDkMfAiZqAFuVcOVtpCemKQpK4QADYQalz4aq7KsirKAPRpuFCuRK6k9tnOrHnZHl6+-oyuOsJoYRAlkTFx3IlyyjV6AHQAZnC0AKLePgAUncaYAHxQGmjscDFdUXC8YyHoAJQbQA"
  load={false}
/>

I prefer the `Pokemon[]` syntax because of reusability. We can use the `Pokemon` type on single Pokemon where it makes sense and `Pokemon[]` on a collection of Pokemon.

This saves us from creating another type and using weird grammar like `Pokemons` to indicate there's many even if Pokemon is already plural.

The next example shows how we can reuse the `Pokemon` type by using it as the argument and return type of the `logPokemon` function.

```ts:playground.ts
type Pokemon = string[] | string

function logPokemon(pokemon: Pokemon): Pokemon {
  if (Array.isArray(pokemon)) {
    return pokemon.map(pokemon => pokemon.toUpperCase())
  }

  if (typeof pokemon === 'string') {
    return pokemon.toUpperCase()
  }

  return 'Please enter a Pokemon.'
}

// ['BULBASAUR', 'CHARMANDER', 'SQUIRTLE']
console.log(logPokemon(['Bulbasaur', 'Charmander', 'Squirtle']))

// 'PIKACHU'
console.log(logPokemon('Pikachu'))

// Please enter a Pokemon.
console.log(logPokemon())
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/C4TwDgpgBACg9gawgWzgOygXigZ2AJwEs0BzAbQF0oAfXA4kgKEYDMBXNAY2EPSgBs4JeElRoAFGEQp0ALljSxASnkiZGAN6MoOqIRZRxAQXz4AhiAB0hHCfMhJi9EqVQtuj1HwRgbfBilRdEtkMzBHIIxMAD4oQPVLYDgAVTBIfABhMxwIcRdtXQBfZg99Q1BIOAN4sSxMbAByPCJSBtd3Tx1vX384pzRElLSITOzcpQKdYsmvHz8MBph+CDGoCDRgEagzBUjLBsZpgHojqDIGgCFkgBkLowBlI2SAJQaAGigGjIAJI2eAWSMADkACIAUVeHwa9wAiskAJLPAAq1zBDQojE46BwcGWlkEJHEBLUYnE5wubH4ACNsmY-O9PhkABZmfChNAAExGDOhAEc2IR8MBluj8owTp8YPCANJGH7JA5YtA4vEEolCEnocSLQgIMycJlsNoTcWnJYrHJrDZbHaagaY7G4iD4oTq4T9PJKIA"
  load={false}
/>

Functions are just special objects in JavaScript which is a roundabout way of saying we can type them as any other object.

```js:example.js
function getPokemon() {
  // ...
}

getPokemon.pokemon = 'Pikachu'

console.log(getPokemon.pokemon) // 'Pikachu'
```

<Image
  height={448}
  width={585}
  src="/images/typescript-fundamentals/13-functions-are-objects.png"
  alt="Functions are objects"
/>

The next example shows ways to type different **function expressions** using a **type alias**.

```ts:playground.ts
type LogPokemon = (pokemon: string) => void

// named function expression
const logPokemon1: LogPokemon = function logPokemon(pokemon) {
  console.log(pokemon)
}

// anonymous function expression
const logPokemon2: LogPokemon = function(pokemon) {
  console.log(pokemon)
}

// anonymous arrow function expression
const logPokemon3: LogPokemon = (pokemon) => console.log(pokemon)
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/C4TwDgpgBAMg9gcwApwNYQLZwHZQLxQAUYamOAXFAM7ABOAltggJT4B8UAbnPQCYBQ-APRCo2AIYYIvKADMArtgDGwejigQAHmFoQqVNdn5KcNKABtEKdFmwBGSvGSlb+OYpWGLVlzmK-sVgBvfigwqBNsKjhzCAA6SwR-GxxmfgBfQREocWwcECx5KndlVXUtHT0DHGNTYG9nFOwAJkcfJrcFUsNkskCoEPCI0xj4xN7bNMzhUVz8wuLxWlo4AHcSz3LtXX1DWqj6xOs+gGY2xr63CdT2YajRhMRrwKA"
  load={false}
/>

The next example shows how we can use a **construct signature** inside a **type alias** to type a constructor function.

```ts:playground.ts
type Pokemon = {
  name: string
  pokemonType: string
}

type PokemonConstructor = {
  new(name: string, pokemonType: string): Pokemon
}

class PokemonFactory implements Pokemon {
  name: string
  pokemonType: string

  constructor(name: string, pokemonType: string) {
    this.name = name
    this.pokemonType = pokemonType
  }
}

function addPokemon(pokemonConstructor: PokemonConstructor, name: string, pokemonType: string): Pokemon {
  return new pokemonConstructor(name, pokemonType);
}

const pokemon: Pokemon = addPokemon(PokemonFactory, 'Pikachu', 'electric')

// PokemonFactory: { "name": "Pikachu", "pokemonType": "electric" }
console.log(pokemon)
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/C4TwDgpgBACg9gawgWzgOygXigbwFBSFRoCGyEAXFAM7ABOAlmgOYFFiIroAq4lN9JqwC+ePKEixOqNAGF0tOgFcAxsDh0suNoTQQA7gApS5KoqEAaKByQzekM4JYBKKvFvo8ovCoA2JamopDzQAMRI1DRAoBmQwXxQINGAg9y4MfCJiMn5zFh1raR4+R0Z8gpUFelV1OmMc0stCkPtcp2ZnbSys4AALBmoAOhNobBGCnv6hm3TWrRm7PgLRbwAzJTQ1BnQoEgATPbSZQwX0eTRFGo03Irkq5Ui6KxHGlitTtFbXjpuQrqI6BBgEo6Bg9PpmulzpdHvVyO9bq1nABuLxiHxVSEyX7pLT7Q63QxHdDhR4gKwAchgDAQEV6SgplIgCTUjBUFOcYgA9FzgulSbUQFQcFAAEQjUVUUXU2kqemiqyij6tSVi5kQVkMFSiqCiSoXOAJQa+ODME63ZxAA"
  load={false}
/>

This is more of a "showing you can do it" example than something you're going to use.

## Interfaces

**Interfaces** are another way to name an object type.

```ts:playground.ts
interface Pokemon {
  id?: number
  name: string
  pokemonType: string
  ability: string
  attack(): void
}

const pokemon: Pokemon[] = [{
  id: 1,
  name: 'Pikachu',
  pokemonType: 'electric',
  ability: '‚ö° Thunderbolt',
  attack() {
    console.log(`${this.name} used ${this.ability}.`)
  }
}]

// 'Pikachu used ‚ö° Thunderbolt'
pokemon.forEach(pokemon => pokemon.attack())
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26TIDeAUMmcsACYD8AXMiAK44BG0p5IcOE9AzmCigA5hzIAHLLnwAVAJ7jeyAUJCjyyOC2AAbYGDn9BIsZrBhEmABQBKegDd0VYgF9ixBPgHJJ2PCHoMP3wAbQBdZABeZBCSDSp6AEYAGlMuHnoAclRgTEQAC0ZM1I1faRB5RSyIHQgEYwRi0y1dfUNkTMBCsmQZQpBKaBZ0HTAmjThzS1siUw1PED5hiAA6HXRhKwADABJCMHzgPmX0iBdkRj4ISmRd-cPllr0DF2XNm1M3FzD3AHofjpyeQQhXOl2u3V6jH6g2Go2IZX8yxg6CgAFEClYEfgogA+HxSRETCwIaw2GxAA"
  load={false}
/>

Inside the **interface** we can say properties are optional using `?` and type required functions like `attack(): void`.

**Interfaces** and **type aliases** are almost interchangable.

You can also use a semicolon or period after each property if you want as it's purely optional.

## Type Aliases or Interfaces?

> For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use interface until you need to use features from type. - [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)

The short answer is ‚Äî **doesn't matter**. Pick one and if it doesn't work for you use the other one.

I use both where it makes sense:

- **Interface** is more appropriate for describing shapes of objects
- You can add new fields to an existing **interface** but not to a **type alias**

We haven't learned about **intersections** yet but briefly it just let's us combine types.

The next example shows how using **intersections** we can extend a **type alias** by combining the type `Pokemon` and `{ pokemonType: 'electric' }` into a new type `Pikachu`.

```ts:playground.ts
type Pokemon = {
  id: number
  name: string
}

type Pikachu = Pokemon & { pokemonType: 'electric' }

// has to satisfy the same checks ‚úÖ
const pikachu: Pikachu = {
  id: 1,
  name: 'Pikachu',
  pokemonType: 'electric'
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/C4TwDgpgBACg9gawgWzgOygXigbwFBSFQCWAJgFxRoCuyARhAE4FFoCGyElAzsI8WgDmeAL548oSLGII2AYwAW1LLEQp0UAGS4oYNajQAVcFygByCABsIcvsTlmoYvAHoXUBW25RgcKNzZgYm4AMxAfBWgAzihFGwRvQF4NwFkdvDl0Xl0ZeSVKGGzFZWx8IhIKKABGABoWQnZOSjN82UKzGtK9JANjSEarGzsHUSA"
  load={false}
/>

In the case of **interfaces** we use the **extends** keyword to extend them.

```ts:playground.ts
interface Pokemon {
  id: number
  name: string
}

interface Pikachu extends Pokemon {
  pokemonType: 'electric'
}

// has to satisfy the same checks ‚úÖ
const pikachu: Pikachu = {
  id: 1,
  name: 'Pikachu',
  pokemonType: 'electric'
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26TIDeAUMmcsACYBcyIArjgEbSnkhw4S0DOYUoAObEAvsWKhIsRClTBMiABb1kEAB6QQlHmiy58RNmQAOevCAAqAT2PdkAcggAbCAn7AE90eID0P5IpwOmDoyDxwYMA8MFbIYIoo4VzICAkImDqAvBuAsjvECPh8yMbySvS0cgqpKgC8huQUNMgAjAA0RnScdvYVpfZt9abY5ta2tI4ubgKeokA"
  load={false}
/>

When using an **interface** you should always keep in mind that you can use an existing **interface** which could lead to some unexpected problems shown in the next example.

```ts:playground.ts
interface Window {
  color: string
  style: 'double-hung' | 'casement' | 'awning' | 'slider'
}

// Type '{ color: string; style: "double-hung"; }' is missing
// the following properties from type 'Window': applicationCache,
// clientInformation, closed, customElements, and 207 more. üö´
const windows: Window = {
  color: 'white',
  style: 'double-hung'
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgOqgCYHsDuyDeAUMicglgDZZQBcyAzmFKAObGmMCeFEdA5NgCuAIx4BaABaCQLPsgA+yPgjj0IAWwjg5ivnBwhWOpfQrAM0PoQC+hQgHp7yACqcADij74ylanUbMMgDcDGDcvMgAREKiEJLSLJEh1nLA9MjqafSsDk5gEigwlFQ4rMhuUFgeUGDAEOkwlerIYR5K6CDYOHx0cG5uZiq1WCAAwogFADS5ZGZaYACSIEVQ6nDDIJOzWGoYWwiCjFjqAKI8muD0W3CdyABMAAwA7BnUEAB0yIC8G4DVe4TkIEYyFKnVw9DoHS6yAAvAR2OQqLQlDgJMBIHxpiQuDx+DFxFIZFZrEA"
  load={false}
/>

The type `Window` is already declared in `lib.dom.d.ts` types for the global `window` object.

Let's briefly touch upon naming conventions. For the most part I just name the type the capitalized version of what I'm trying to type. For example `pokemon` would be `Pokemon`. Sometimes that's not enough when dealing with something like React where component names are capitalized so you can use a suffix such as `PokemonType` for a **type alias** or a prefix `IPokemon` for the **interface** or even your own convention such as `PokemonProps`. For some reason using the `I` prefix in TypeScript for **interfaces** is controversial but I think it's alright as long as you're consistent with your naming conventions.

## Intersection Types

**Intersection types** let us combine types using the `&` operator.

The next example also shows how we can use **interfaces** and **type aliases** together where it makes sense.

```ts:playground.ts
interface Pokemon {
  name: string
  hp: number
  pokemonType: [string, string?]
}

interface Ability {
  blaze(): void
}

interface Moves {
  firePunch(): void
}

type Fire = Ability & Moves

type FirePokemon = Pokemon & Fire

const charizard: FirePokemon = {
  name: 'Charizard',
  hp: 100,
  pokemonType: ['fire', 'flying'],
  blaze() {
    console.log(`${this.name} used üî• Blaze.`)
  },
  firePunch() {
    console.log(`${this.name} used üî• Fire Punch.`)
  }
}


charizard.blaze() // 'Charizard used üî• Blaze.'
charizard.firePunch() // 'Charizard used üî• Fire Punch.'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26TIDeAUMmciHDhAFzIDOYUoA5qeQBYAOdIArjgBG0dmS5Zc+ACoBPLrWQBtRsxAsANAyasA-AF1iAX2LFQkWIhQBBQcAA2wMDKKjkgu3ABeEABQBKOgA3dGAAEyMTM2h4JGQAWXRAiHoXcmQYYCgIVD4QBA5-IJDw42IneWQAMUyUAF5kG3tHZwAyeMTkk3KUaqyMbDwCev7JAjbeiBMEfEZkfLhmTwXQugmRweR6kjTKajoAcgBhDgXgJahQ-fVXbjoARgAGB+u08QHpOQVFfYysq+QfnYZKx9noXuR3F5fH5UmlyNMQPR0HYIAA6OzoFg+AAGABJCGAOMB6KjdhBDMg+PQIKFkIBeDcApLvIABCHm8qOxflchnBZF+2Vy+X8sLhcxmyLRGKxeIJRJJZIpVJp9KZEzQgo4HK5aWMpWI80Wy1RkO8woA9GaAcdTudaUraYyWWy0ft9SdDRdUfycnkCjCLVb3WdlpTqQ7VTV1b7UfsgA"
  load={false}
/>

I threw in a sneaky **tuple** in `pokemonType` because a Pokemon can have dual-types. We're going to learn more about **tuple** later.

If we wanted to use an **interface** we could and it works just the same.

```ts:example.ts
interface FirePokemon extends Pokemon, Ability, Moves {}
```

It's easier to compose types using **type aliases**.

## Type Assertion

**Type assertion** is like type casting in TypeScript where it can be used to specify or override another type.

In this example TypeScript only knows that `formEl` that uses `document.getElementById` returns some kind of `HTMLElement` meaning we can't use some of the built-in form methods.

```ts:playground.ts
// formEl is `HTMLElement | null` because it might not exist
const formEl = document.getElementById('form')
```

These types correspond to the [browser API](https://developer.mozilla.org/en-US/docs/Web/API). [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) is the base class other elements inherit from. [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) is the base interface for HTML elements. That's how we get to the [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement) that represents a `<form>` element in the DOM (Document Object Model).

```ts:playground.ts
const formEl = document.getElementById('form')

// Property 'reset' does not exist on type 'HTMLElement'. üö´
formEl?.reset()
```

If you're not familiar with the [optional chaining operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) it just says to TypeScript the value can't be `null`.

```js:example.js
// short-circuit evaluation
formEl && formEl.reset()

// optional chaining
formEl?.reset()
```

It's a relatively recent addition to JavaScript, so you might not be familiar with it. If the value doesn't exist it's just going to return `undefined`.

If we look at the API for HTMLElement the TypeScript error makes complete sense since that method doesn't exist.

We can be more specific about the type of element with **type assertion** using the `as` keyword.

```ts:playground.ts
const formEl = document.getElementById('form') as HTMLFormElement

formEl?.reset() // works ‚úÖ
```

The üß† pro-tip of how to figure out what element you want is fumbling around until your code completion gives you an option that looks like the option you want.

There's also the alternative angle bracket `<>` syntax for **type assertion**.

```ts:playground.ts
const formEl = <HTMLFormElement>document.getElementById('form')

formEl?.reset() // works ‚úÖ
```

Don't confuse this syntax with TypeScript **generics**.

The angle bracket syntax is avoided because it gets mistaken for React components because of JSX.

We can observe this error in the TypeScript Playground because in the **TS Config** the JSX for React option is on by default.

```ts:playground.ts
// JSX element 'HTMLFormElement' has no corresponding closing tag. üö´
const formEl = <HTMLFormElement>document.getElementById('form')
```

In the example I disabled JSX in the TS Config options.

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?jsx=0#code/DYUwLgBAZg9gTgWwKLAFCtolEC8EAmMAxgK4IgB2YAdAObgojlUBCAngJL4AUA5Jgl4BKdAHpREAApwYABxBwwbCLzggAzuF4EYGiBRiQQADwCW6yDAoQl8lQAkAKgFkAMo2Zhe1CIF4NwNV7GPDIwAD81GqaYNwiQVjAuDqknnQMoJ7sXHwCwhAAhuoQTm4AYsEelGBiEgDu8ADWhYCg5HEh4ZHgMegC2HgAPMWuZfFMlQB8hMmVqWAVrJw8-MG51RAAUgDKABoE5nkARqD4EC09YREanUJAA"
  load={false}
/>

Event listeners are a big part of JavaScript and something we use often even when using JavaScript frameworks.

In the next example we have a input field that takes a Pokemon name and has an event listener on it.

```html:example.html
<input type="text" id="pokemon" />
```

```ts:playground.ts
const pokemonInputEl = document.getElementById('pokemon') as HTMLInputElement

function handleInput(event) {
  // do something
}

pokemonInputEl.addEventListener('input', (event) => handleInput(event))
```

When you hover over `event` in `addEventListener` notice the infered type `Event`.

This makes sense because [Event](https://developer.mozilla.org/en-US/docs/web/api/event) is the base interface for events. Derived from Event there's [UIEvent](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) that has other interfaces like [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent), [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent) and [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) among others.

This is a teachable moment that let's us know we can leverage TypeScript to help us figure out built-in types instead of having to look it up.

```ts:playground.ts
const pokemonInputEl = document.getElementById('pokemon') as HTMLInputElement

function handleInput(event: Event) {
  // Object is possibly 'null'. üö´
  // Property 'value' does not exist on type 'EventTarget'. üö´
  event.target.value
}

pokemonInputEl.addEventListener('input', (event) => handleInput(event))
```

The problem we face has to do again with the type not being specific enough. We want the `value` from `event.target` but we can see the type is `EventTarget` so TypeScript doesn't let us access that property.

```ts:playground.ts
const pokemonInputEl = document.getElementById('pokemon') as HTMLInputElement

function handleInput(event: Event) {
    const targetEl = event.target! as HTMLInputElement
    targetEl.value
}

pokemonInputEl.addEventListener('input', (event) => handleInput(event))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBADiA1gUwLbgJJjgVygUQBsYBeGAExGB1WTCgDoBzZAwtOqAIQE8NyAFAHIEKdGCEBKGAEMIMABIAVALIAZLLjYd6AKF0AzHGGBQAluBgALGWHLtNeAcgBunAFwx8b+tIDeujBBMKCQsFAyAE4sbKQwrpwMEdGsAISy8srqjtq0esEwyTFEDC4yhDjIugC++qJomNh4JTLk5N6cambQdMiRwmZNUEIANDDOPlDSJAB81rb2yDkTnJKSQA"
  load={false}
/>

TypeScript knows the type is `HTMLInputElement`, so we can use it's methods and properties.

You don't have to keep this knowledge in your head. Let TypeScript and your editor help you.

```ts:playground.ts
// event is `MouseEvent` üê≠
window.addEventListener('mouseover', (event) => console.log('Mouse event'))

// event is `TouchEvent` üëÜ
window.addEventListener('touchmove', (event) => console.log('Touch event'))

// event is `KeyboardEvent` üéπ
window.addEventListener('keyup', (event) => console.log('Keyboard event'))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/PTAEFMDdwOwF1ASwM6gAYFkD2BXZ4BRaeNUQXg3BaHYCgB3RGAEyxoDoBDBho2OAGRTixwAJwAUAcgC2ufFmjDxAGlCioPAJSgAvAD5QAYywxkWADbgWprAHMJ2POAjE449eqpUQTnklRoAKrj6ABbcJOSAYju09EysHFzO-MiCMCIScEHB0tBKKmrwmroGRibmljYSgTgh3vCu7p5g+Qgo6ADS4ACeAEZYbMIJPKSAPBuAnfvRjMzsnGF8AkJi4gDWXTgADrmqzoV6hsZmFla24h09fQO1Lm5AA"
  load={false}
/>

In the previous example we used `!` that asserts the type can't be `null` but keep in mind that when using any **type assertion** you're saying the element can't be `null`.

```ts:playground.ts
// HTMLElement | null
const pokemonInputEl = document.getElementById('pokemon')

// HTMLInputElement
const pokemonInputEl = document.getElementById('pokemon') as HTMLInputElement
```

That being said don't lie to the TypeScript compiler and only use **type assertion** when you have to.

## Type Assertion Using `!`

Using the `!` syntax after any expression is a type assertion that the value isn't going to be `null` or `undefined`.

```ts:playground.ts
const formEl = document.getElementById('form')! as HTMLFormElement

formEl.reset() // works ‚úÖ
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAZiATgWwKIBsYF4YBMTACuyApmFAHQDmJUGJp5AQgJ4CSuAFAOQIrcBKAIQwAhhBgAJACoBZADIAxJGnQMyUAFCa+qiohIRanATAD0ZmAHckAawmBQciA"
  load={false}
/>

## Type Assertion Conversion

Using `any` and **type assertion** is great when you're just writing code but avoid using them unless you have to.

TypeScript tries it's best to not let you do something stupid.

```ts:playground.ts
// Conversion of type 'string' to type 'number' may be a mistake because
// neither type sufficiently overlaps with the other. If this was
// intentional, convert the expression to 'unknown' first. üö´
const pokemon = 'Pikachu' as number
```

That doesn't mean you can't do whatever you want.

```ts:playground.ts
const pokemon = 'Pikachu' as unknown as number

// no complaints, but wait until you run your code üí•
pokemon.toFixed()
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/DYUwLgBADg9g1iAtjAdgLggQxQTwFB6wLIoQC8EA5AAoCWcmAxgBYCulWAzhCq4gEYgATgSJJUAOjAwAYrQAeIACYAKAJQQA9JoiBeDcDVe6PjjSFGvSZsOmbqxRwUMAO6kbPPoJGFjJKbIXK6lo6uoClO0A"
  load={false}
/>

TypeScript only allows **type assertions** that convert to a more specific or less specific version of a type.

## Literal Types

**Literal types** are exact values of strings and numbers.

> Both `var` and `let` allow for changing what is held inside the variable, and `const` does not. This is reflected in how TypeScript creates types for literals. ‚Äî [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)

TypeScript has `string`, `number`, and `boolean` literals. The `boolean` type itself is just an alias for the `true | false` union.

```ts:playground.ts
// type is string
let pokemonLiteralType = 'Pikachu'

// type is 'Pikachu'
const pokemonGeneralType = 'Pikachu'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/PTAEBcE8AcFNQJYGdRPAJwQOwOYCgAbWcUaAewGtYBbMrAGQXFnQEMCAVGeAXlAHIACggqsAxgAsArvzx4QEbohRCR46bLF00pSjToBxWFhbsucUH1WjJMvEA"
  load={false}
/>

This concept is more useful if we combine **type literals** into **unions**.

```ts:playground.ts
function movePokemonOnBoard(
  direction: 'up' | 'right' | 'down' | 'left'
) {
  // ...
}

movePokemonOnBoard('up') // acceptable value ‚úÖ
movePokemonOnBoard('rigth') // oops! typo. üö´
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWzgNwKYAU4GsOpgDyYAQnAIYBOAJgBQBQiiNMVG08YAXIgOQgADn0QAfflRgBzABZQR4vjTgB3MAv4AbDMHkMAlIgDeTRAHoziAHQ2GAXwYNUmHPkIly1egOGGLiCggIDEEoCgAjbUQ0Ck0QDERAUHIndGw8AgQPSlo6PkkpKBk+P0s4OEEAZwBCRCgAT0E4K0RAXg3Aar2gA"
  load={false}
/>

## Literal Inference

**Literal inference** is when TypeScript thinks properties on an object **might change**, so instead of infering a **literal type** it infers a **primitive type**.

Types are used to determine reading and writing behavior:

```ts:playground.ts
function addPokemon(name: string, type: 'fire' | 'water' | 'electric') {
    console.log({ name, type })
}

const pokemon = {
  name: 'Pikachu',
  type: 'electric'
}

// Argument of type 'string' is not assignable to
// parameter of type '"fire" | "water" | "electric"'. üö´
addPokemon(pokemon.name, pokemon.type)
```

There's two methods we can use to solve this problem.

The first method is using type assertion:

```ts:playground.ts
const pokemon = {
  name: 'Pikachu',
  type: 'electric' as 'electric'
}
```

The second method is using the `as const` suffix that acts like the type equivalent of `const`:

```ts:playground.ts
function addPokemon(name: string, type: 'fire' | 'water' | 'electric') {
    console.log({ name, type })
}

const pokemon = {
  name: 'Pikachu',
  type: 'electric'
} as const

addPokemon(pokemon.name, pokemon.type) // pokemon.type is 'electric' ‚úÖ
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAQwCaoApwNYFMC2CAFGMvrgFyIDOUATjGAOYA0iUAngA6WIDkwGHVx9EAH34B3ZFFx1REvrgA2uaAwh8AlIgDeAKERHEEBNTiqAdMrhMiuxKXJtOPRAF8t+9-v2mwtIhcOAQIiAC8eobGTrx8GDDYyBAAFiB8LNFGrnEqavQwmt4o1CZmUL76aJghhGBEwXh1lrFsjaFgljk6APQ9QbUIXdy4iDClSqrqhaKAoOT6QA"
  load={false}
/>

This makes sure properties are assigned a literal type instead of a general type like `string` or `number`.

If we hover over `pokemon` in the first example the type was:

```ts:example.ts
const pokemon: {
  name: string
  type: string
}
```

After we added `as const` a special `readonly` property was added:

```ts:example.ts
const pokemon: {
  readonly name: "Pikachu"
  readonly type: "electric"
}
```

This signals to TypeScript the values of `pokemon` won't change.

## Object Index Signatures

In times when we don't know the properties of an `object` ahead of time but know the shape of the values we can use **index signatures**.

JavaScript has two ways to access a property on an `object`:

- The dot operator `object.property`
- Square brackets `object['property']`

The second syntax is called **index accessors**.

This is reflected in the types system where you can add an **index signature** to unknown properties:

```ts:playground.ts
interface PokemonAPIResponse {
  [index: string]: unknown
}
```

<Image
  height={503}
  width={734}
  src="/images/typescript-fundamentals/16-pokemon-api.png"
  alt="Pokemon API"
/>

This shows the Pokemon API response.

We're using an **index signature** to indicate that the keys of the object are going to be a `string` with a `unknown` property.

This is useful where we don't have control over an API or time to type out a complex interface.

We might only care about some properties:

```ts:playground.ts
interface PokemonAPIResponse {
  [index: string]: unknown
  base_experience: number
  id: number
  name: string
  abilities: Array<{ ability: { name: string, url: string }}>
  moves: Array<{ move: { name: string, url: string }}>
}

async function getPokemon(name: string): Promise<PokemonAPIResponse> {
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)
  const pokemon = await response.json()
  return pokemon
}

async function logPokemon() {
  const charizard = await getPokemon('charizard')

  // Object is of type 'unknown'. üö´
  console.log(charizard.order.toString())

  // we need checks in place for properties we don't know about
  console.log((charizard.order as number).toString())


  // we get great code completion for propertes we know about
  charizard.abilities.forEach(({ ability }) => console.log(ability.name))
}

logPokemon() // '7', 'blaze', 'solar-power'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26QCCqAkgEoQDOADvhSgN4BQyLyA2qACYQAeAXMgpgooAOYBdAQFcQmEOgDuIZqwBGcOgH1eVaMAggkAkFJyroKlsE7HT5qJeQg4OCAKEiQox3FXAANsBg+hQCBFBQcACeADz0yL4BQVEC8c6u7sJiADTIUlD+mZ6iyAC+pQB8jngAbpRhEdFxyLVuyGkubR45eQVFYmWVjKWMjBpRhsgwMgjB+MiiEGAY2HggABTpXVleAJQCqFDoOMB0MSu4+ERklDQgdBXtjgi0YMhQt7QoALwJCnBBKZLBAAC3WAAMQWAwFRQgB6OE0bBwKjAAB0LzhKOAcJqACZEVhLiA4QASehbUrg3bPV7IJHE5C-OD-QEfahfNEAKwo+HWNNY7yW+RA9KJa2Go3Gk2mhjmov86FEFzW-Kegpe9zeoLgIgAXrrOEy-gC3otluK+QByHX6w1WmmOBHIADyqi5EFmyFOyHQMGQYCiumQVpkckUICtaOQgF4NwDVe7T7uh-BA0YrROtbcADVBOGj0LnoGiwOgAMo7DO7R2C50KFAgCAQI2gz2YCje0VUfyIFAwAv0o66KDBSjIOvITj4K1vcMKBKqdBSMCJ3kptNK9aZkG67OG-OFqAJdsmMzQXbFssV-nV1hOuFjlDmhYfODa9DcZAvHBdpbAeZ9w8qEHaBIHbcdZ3nRdlw1bc7VzNFEkCEcKDRACAFFEDBdZ4kQ5Iyl2JlHk1VdU3TdZcMDNEtirSVGHTFU+QI50rQAditXIrVUbs9QgdiQ1XXUAFoaDrKArSAA"
  load={false}
/>

Take Pokemon ratings for example where we don't know the Pokemon ahead of time:

```ts:playground.ts
type Rating = 1 | 2 | 3 | 4 | 5

interface PokemonRatings {
  bulbasaur: Rating
  charmander: Rating
  squirtle: Rating

  // unknown properties are covered by this index signature
  [pokemon: string]: Rating
}
```

Let's explore a common confusing situation you're going to encounter using TypeScript.

You often have some dynamic code where you're accessing the properties of an object:

```ts:playground.ts
interface Stats {
  id: number
  hp: number
  attack: number
  defense: number
}

interface Pokemon {
  bulbasaur: Stats
  charmander: Stats
  squirtle: Stats
}

const pokemon: Pokemon = {
  bulbasaur: { id: 1, hp: 45, attack: 49, defense: 49 },
  charmander: { id: 2, hp: 39, attack: 52, defense: 43 },
  squirtle: { id: 3, hp: 44, attack: 48, defense: 65 }
}


const bulbasaur: string = 'bulbasaur'

// No index signature with a parameter of type 'string' was found on type 'Pokemon'. üö´
pokemon[bulbasaur]
```

Try reading the error message without using interfaces in the example. It's almost unreadable.

What does this mean? Since objects are `number` indexed we're trying to access the property by using a `string` index. In reality we want to access the `pokemon` object using the literal `bulbasaur` for the key instead of `string`. This is what you should keep in mind.

We can see this is true if we change the **index signature**:

```ts:playground.ts
interface Pokemon {
  [pokemon: string]: Stats
  bulbasaur: Stats
  charmander: Stats
  squirtle: Stats
}

pokemon[bulbasaur] // careful if this is what you want ‚ö†Ô∏è
```

What you should do instead is make sure what you're passing is a **type literal**:

```ts:playground.ts
const bulbasaur: 'bulbasaur' = 'bulbasaur'

pokemon[bulbasaur] // correct ‚úÖ
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMpjmAzsg3gKGSOWABMAuZEAVwFsAjaQ4gCwAdKaGnjlMMEAa051GUZkVIQYEEFggju4gL758oSLEQoACgHtBEWnpB4JyetQA29OFjjUoldJizmELOFFpwQUp2gY2OZYAI7UwFBgVgqBrviq+AgmWGDIbAZGJpT6hsamALxmvJY2dg4BuCQUyACMADTI7JQALACsjfyIwsgtAJyNUjJysf3IyvXunt6+-pRVZJQATI3NyADMA3xgAj1tK8hDsvKt6+OTvGERUTHz1ZTrqxy9LZ073a0AHIPSx7EAbG1xgk1Mk5GlSrZ7I5KKkoKAAObIIoAckh5UcKKSKTSHi8Pj80EoKLxM0JUBRyOQJOmBP8WJiaSukWiKFRzJuEEpdmQYNSagyeRMAG10dCoABdfCCrIgYWkunQKUy-LCjmsqVAA"
  load={false}
/>

I only made the type explicit so it's obvious. `const` is going to infer a **type literal**. We can also use the `as const` assertion.

## Type Narrowing

**Type narrowing** is when you narrow types to more specific types:

```ts:playground.ts
function getPokemonByType(pokemonType: 'fire' | 'water' | 'electric') {
  // type is 'fire' | 'water' | 'electric'
  if (pokemonType === 'fire') {
      return 'üî• fire type Pokemon'
  }

  // we narrow it down to 'water' | 'electric'
  if (pokemonType === 'water') {
      return 'üåä water type Pokemon'
  }

  // we narrow it down to 'electric'
  pokemonType

  // TypeScript knows only 'electric' is possible
  return '‚ö° electric type Pokemon'
}

getPokemonByType('electric')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAcwKZQApwNaoLYIBCAngCrEAOqAFBTvguVQFyIDkwMATqm4gD7sA7gEMoqLn0FtUAG1TQuMCGwCUiAN4AoRIgD0exFEqpEMAM7tOPKcLETbM+YuVsdZ4Ilr0CYJqYBeIKtuXnVtXUjEHigQLiQ2QF4NwFJdxGtTYypELFxfN10AXy13A0QhUzARLi44ITMoRAATWqQoODtxSQF2OQUoJRV3GE9vXMYTRCCAjodw9yiYuITAHg3AKH2y+y4jCZyGMHzEIpLDcsRK6tr6ppajdqc+gYO6Mb8TYt1S-wBlCCUKBuwYFqlgQsmIPWc-VcZksdHM5hgACN5O5FvF2IBCskQvRcEG2WV2eS0RzQmB8RDIJmo91xaiAA"
  load={false}
/>

Let's appreciate for a moment how cool it is that TypeScript just knows the type we're dealing with based on analyzing the code flow. ü§Ø

Using the `in` operator narrowing:

```ts:playground.ts
type Fire = { flamethrower: () => void }

type Water = { whirlpool: () => void }

type Electric = { thunderbolt: () => void }

function pokemonAttack(pokemon: Fire | Water | Electric) {
  if ('flamethrower' in pokemon) {
      pokemon.flamethrower()
  }

  if ('whirlpool' in pokemon) {
      pokemon.whirlpool()
  }

  if ('thunderbolt' in pokemon) {
      pokemon.thunderbolt()
  }
}

const pokemon = {
  name: 'Pikachu',
  thunderbolt() {
    console.log(`${this.name} used Thunderbolt.`)
  }
}

pokemonAttack(pokemon) // 'Pikachu used Thunderbolt.'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/C4TwDgpgBAYglgJ2gXigbygMwDYEMC2EwAFggPYDuECAXFABQCUUyAfFAG5lwAmUAvgChBoSFADquYNRbooFYomxgyZbHSYt2XXgOGjoAUWwQAxsARxTsjCQCuAOx7UARmuAbmbTtz5DBmI7mcGQOUCoA1hD4oQCCwMC4phH0kdGhdPBIUAA+ElIyecZmFlbMaIJQVVBwmAwA5DgERKSU1PU1YWkxDuWV1QPdoQB0TYQk5FQITP1V-gO1DQpKKmodcF1kUT19A4Nb6Q7DywjKqtgzA-PVi-T19k6u7uub26G7e1VDRw-OCG7YYCXapCfymUIAZ2A4QOPRssygDmadHqAAU4BEksQ7PUADQI35PQGaCqfKrghwQtQQYbYMgAc3oAAMACRoEhwCHDJGEfhQOwQiB8AAq2Me-3cwyZjARoOE33iiWSqVh7ygAHp1VA0RisXZ+YKRWK-gDgMN6kA"
  load={false}
/>

Using `instanceof` narrowing we can check if a value is an instance of another value:

```ts:playground.ts
function logDate(date: Date | string) {
  if (date instanceof Date) {
      console.log(date.toUTCString())
  } else {
      console.log(date.toUpperCase())
  }
}

// 'THU JUL 01 2021 20:00:00 GMT+0200 (CENTRAL EUROPEAN SUMMER TIME)'
logDate(Date())

// 'Thu, 01 Jul 2021 20:00:00 GMT'
logDate(new Date())
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwCIEMoFMAUAJjrgFyLZ6IA+iAzlAE4xhoCUiA3gFCJ+IxgiIiQFgGWSLjhDKuDj35LEEBHTjJcAOlRoReLVDgBVACoBhAMpMWeth2WP+vfgF9EuZHVxcXj1eIa2rr62kbGAA4RuIzmWN749nx+iK7cadwA9JmIAOSmABLGiABSxgAyiAAMAIyIAExV9XWNpFVVbVWIAOIAsqYA1E3twuYAogBypgBKAIKVY8bTAPIACmOzE4iWxr29Y9OIpgCS+2y53Lpy+Nf23Fk5+QAWIAA01XUlIMgNTS0d7U6PX6FyuJHwYFwAHcKOD7EA"
  load={false}
/>

If you remember from a previous example there's a distinction between the constructor `new Date()` that returns an `object` and function `Date()` that returns a `string`.

You can [read more about narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) that covers some plain JavaScript concepts if you're not familiar with truthiness and equality checks.

## Type Guards

A **type guard** is checking against the value returned by `typeof`.

Because TypeScript knows _everything_ üëÄ it can save us from some JavaScript quirks:

```ts:playground.ts
function logPokemon(pokemon: string[] | null) {
  if (typeof pokemon === 'object') {
    // Object is possibly 'null'. üö´
    pokemon.forEach(pokemon => console.log(pokemon))
  }

  return pokemon
}

logPokemon(['Bulbasaur', 'Charmander', 'Squirtle'])
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgziA2CmB0w4EMBOAKAlAKGwMwFcxgAXAS3AAJoQBzABRAGtYBbcdAB2bfAC5KEEqjJhaAbQC6lAD6UwBaNEyUA3tkqbKZPJXQkAnp1ghd3FuzCUAvLcoByEACMAVrFL2V6rT8rneYPB4IKgAosjAABZcPJY2AHyUoJAwCDS0MRbgmDg+AL64PqiwJASoVv6W2AXY6YxZYOji9gBCik7IEMhl9gA0DgDCkWisyGAAJrCofQ4AygCOBGSoJHD2kphAA"
  load={false}
/>

In `logPokemon` we naively check if `pokemon` is an array by checking if it's an `object` since almost everything in JavaScript is an object. Unfortunately, so does `null`.

In JavaScript `null` is a primitive value that returns `object`:

```js:example.js
typeof null // 'object'
```

This mistake is part of the language. You can [The history of ‚Äútypeof null‚Äù](https://2ality.com/2013/10/typeof-null.html) if you're interested.

TypeScript let's us know the `pokemon` type was narrowed down to `string[] | null` instead of just `string[]`.

## Type Predicates

**Type predicates** are a special return type that acts as type guards for functions.

```ts:playground.ts
interface Pokemon {
  name: string
  itemType: string
}

const items = [
  {
      name: 'Pikachu',
      itemType: 'pokemon',
  },
  {
      name: 'Berry',
      itemType: 'consumable'
  }
]

function isPokemon(value: any): boolean {
    return value.itemType === 'pokemon' ? true : false
}

function filterPokemon(items: unknown[]) {
  return items.filter(item => {
    if (isPokemon(item)) {
      // Object is of type 'unknown'. üö´
      console.log(item.name)
    }
  })
}

filterPokemon(items) // 'Pikachu'
```

In the above example:

- `isPokemon` returns `true` or `false` based on if there's a `itemType` property with a value of "pokemon"
- In `filterPokemon` we try to narrow down the `item` type with the `isPokemon` check but `item` is `unknown`

How do we narrow the type of `item` to be `Pokemon`?

**Type predicates** let us do that if a function returns `true` they change the type of the parameter to something more useful.

We can do this using the `argumentName is Type` syntax:

```ts:playground.ts
function isPokemon(value: any): value is Pokemon {
  return value.itemType === 'pokemon' ? true : false
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26TIDeAUMmciHDhAFzIDOYUoA5qecJDgCoCeADrQZNWxAL7FiCfI2Sdc9ZAF5kAbXZkS5bRSpCA5KmCZEACwCu+gDQad8ngIP8sufNdtib2rTrKVqdPoAQtBQvO6+ZPZ8goHSIPTmOHAARgA2EPoexAC6kjDmIAhgwPhy9BjYeCAAFABucGnmQnAgvACUdA1NKMCKla4EPmRQEGDmUATdzQB00Y7KSir6zlVuyAD8yEzNyHTwafQQ4vmFxaUEMMBpkFAD1TX29HSFmCDoAO4gqjntRLajcaTORcegzK43aCPLjKAB8-0ichgyEeFRcD3s7T+w0RyHi9HQGRmaXQLGhuBm-gg7Vs2gkdJpEmIENu93w5Jw9D+AHpuchDMYzJYgA"
  load={false}
/>

The `item` type is narrowed to `Pokemon` and we can access it's properties.

## Generics

**Generics** are variables for types.

We use **generics** to create reusable pieces of code that can work over a variety of types rather than a single one.

The first **generic** we have encountered was the **array type**:

```ts:playground.ts
const pokemon: Array<string> = ['Bulbasaur', 'Charmander', 'Squirtle']
```

If we hover over `Array` we can see it's using an interface `Array<T>` where `T` represents a type variable. That means we can pass any type it supports.

Generics make our types flexible:

```ts:playground.ts
const pokemon: Array<{ name: string, pokemonType: string }> = [{ name: 'Pikachu', pokemonType: 'electric' }]
```

We can use make the code more readable by using a **type alias** or **interface**:

```ts:playground.ts
interface Pokemon {
  name: string
  pokemonType: string
}

const pokemon: Array<Pokemon> = [{ name: 'Pikachu', pokemonType: 'electric' }]
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYewdgzgLgBADiA1gUwLbgMpQE4EswDmAgttgIYCeAXDCeRQDzR6EB8MAvDANoDkAQgFcANgCMyEMoOy8ANDF4BhABZlsqMmAAmyGfN4YAjoNzYow5LwC6AKBuhIsBCnRgA8qIBWyYFDqUaf0YAbxgwMlRkGmZ8AnlnNHAAFQo4KJgYwhgAX3YublDwyJpeAAVcRDJgZUE5eCREsBS0kuQLXzxgXhzbG3woXQAzKuQYUobXGGCbGFmwiPTMghm5hNdmxZxYm2y7B2h6l3APb18ggCZA0koGcaOwPJ5ChZLyyura+Ink1PTeNp8Wy6PT24AOa2OXkBQQAzDQ7o1uFZOE95sUFG8qjU6hCmr9Wu0gd1slYgA"
  load={false}
/>

Instead of the `Array<Pokemon>` syntax we can use the equivalent `Pokemon[]` syntax if you remember what we learned before.

We're going to dive deeper later how to read and learn from type definitions. This is going to give us even more insight.

Generics can be hard to wrap your head around at first. You also don't know when you would use them until you get into such a situation.

Let's look at an example where we log Pokemon:

```ts:playground.ts
function logPokemon(pokemon: any) {
  return pokemon
}

const log1 = logPokemon('Pikachu')
const log2 = logPokemon(['Bulbasaur', 'Charmander', 'Squirtle'])
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAFAA44EIBciAhmAJ4CUiA3gFCKeIBOuUI3JGTyEwbAL5s2EBAGcoKdAEZEAXkWZyoogHIMMbDQgALEDsbS5C1GgBMajVhHEA2joBCIZACMasmgI6ADSIOgDCxjTc+HQAJrjcwaEAygCOIDDcUMi4OgC6FkA"
  load={false}
/>

We have no idea what the user might pass as the `pokemon` argument so we don't know the type ahead of time.

If we hover over `logPokemon` we can see the infered type is `(pokemon: any): any`. We can also observe that `log1` and `log2` are `any`.

We might use a **union type** to limit what you can pass in:

```ts:playground.ts
function logPokemon(pokemon: string | string[]) {
  return pokemon
}

const log1 = logPokemon('Pikachu')
const log2 = logPokemon(['Bulbasaur', 'Charmander', 'Squirtle'])

// Property 'toUpperCase' does not exist on type 'string[]'. üö´
log1.toUpperCase()

// Property 'map' does not exist on type 'string'. üö´
log2.map(pokemon => pokemon.toUpperCase)
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAFAA44EIBciAzlAE4xhqIA+tDTaA2gLoCUiAN4AoROMT1cUEPSRk8hMCIC+IkRAR0U6AIyIAvDszklRAOQYY2AIYQAFiHP8NWqMYBMh41kXFu5gBCIMgARjY0NrLmADSI5gDC9jb0+DZgACa49LHxAMoAjiAw9FDIuOYC6gD01YgY9HAk2VAAnvFQcACqJM30CREViBlwuDSIYHDuuAAeMNoIiG3N8XSMzHzmAHSIgLwbgNV7IqhouludPX0DNLhELiK19Y19bfFpJObDo+OT03MLSMtcKtOMxtntDscPFs3qRTIsDAA+RAKChgM7dXrZK64FxAA"
  load={false}
/>

Since we can't narrow down the type and the union members don't overlap we get a TypeScript error.

If you hover over `logPokemon` it says the call signature type is `(pokemon: string | string[]): string | string[]` and hover over `log1` and `log2` the type is `string | string[]` despite us passing in different values.

What if you could let the user pass in their own type?

```ts:playground.ts
function logPokemon<Type>(pokemon: Type): Type {
  return pokemon
}

const log1 = logPokemon('Pikachu')
const log2 = logPokemon(['Bulbasaur', 'Charmander', 'Squirtle'])

// string ‚úÖ
log1.toUpperCase()

// string of arrays ‚úÖ
log2.map(pokemon => pokemon.toUpperCase)
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAGzgcwApwNYFMC2CAPACoCeADrgHwAUFOBCAXIuVQJSvu6IDeAKETDEAJ1xQQopAzyEwAgL4CBEBAGcoKdAEZEAXm2ZG82gHIMMbAEMIACxBmOqjVtRoATAaNY5CWgDaZgBCIMgARtbq1lJmADSIZgDCdtai+NZgACa4ovGJAMoAjiAwolDIuGYAus4qAPT1iJqiMGBoiICg5ALuOgB0UHAAqhRUoklRuLR1jc1Qre2IcMCIaaLWZOpdPegefRkU9CYIBtSIskxgA8OjuRPquBxAA"
  load={false}
/>

The generics syntax looks like `<T>` where `T` represents the **type variable.** You might see the single letter `T` used instead but I think it's confusing. It makes the code harder to read and you might assume you have to use `T` as a type name. **You can name the type variable anything you want.**

In the above example we're saying the `logPokemon` is a generic function that takes a type parameter `Type` and an argument `pokemon` of `Type` and returns `Type`.

If we hover over `logPokemon` for `log1` we can see the call signature matches the string we passed in `logPokemon<"Pikachu">(pokemon: "Pikachu"): "Pikachu"` and `log1` is the type literal "Pikachu".

If we hover over `logPokemon` for `log2` we can see the call signature matches the array we passed in `logPokemon<string[]>(pokemon: string[]): string[]` and `log2` is the type `string[]`.

We can also be explicit when using generics:

```ts:playground.ts
const log1 = logPokemon<string>('Pikachu')
const log2 = logPokemon<string[]>(['Bulbasaur', 'Charmander', 'Squirtle'])
```

You're going to see generics everywhere. Now you know they're not that spooky.

Let's look at an example of the map array method:

```ts:playground.ts
function map(arr: any, callback: (arg: any) => any) {
  return arr.map(callback)
}

const formatPokemon = map(['Bulbasaur', 'Charmander', 'Squirtle'], (pokemon) => pokemon.toUpperCase())

console.log(formatPokemon) // ["BULBASAUR", "CHARMANDER", "SQUIRTLE"]
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWwIYAcAUqBOOBciqYAngDSISoA21ARqhANaHY4DmhxJAlIgLwA+IqT4BvAFCJpiHAFMoIHElw4AdGixVaDZjwkBfCRIgIAzlETA4ONFAAKcJnOQIBKDJgDaAcgBCIPSoZqhKPhQ+AMIAFrhoYAAmcjjhiD4AygCOIDA4UNRyPgC6FJjoTi4IfEKI5c6uYGpQcACq6OjJkcFymDz6JuZwBWrUcOyY1raoDhUN+kA"
  load={false}
/>

There's a couple of thoughts I have:

- We can't know the type of array since you're able to pass any type of array
- The callback function could have any argument and return type based on that array
- We can't type the return, so `formatPokemon` is of type `any`
- There's two arguments that represent the input and output

So far we have only seen generics with one type variable but we can use as many type variables as we want:

```ts:playground.ts
function map<Input, Output>(arr: Input[], callback: (arg: Input) => Output) {
  return arr.map(callback)
}

const formatPokemon = map(['Bulbasaur', 'Charmander', 'Squirtle'], (pokemon) => pokemon.toUpperCase())

console.log(formatPokemon) // ["BULBASAUR", "CHARMANDER", "SQUIRTLE"]
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWwIYAcA8BJM6RQA0iA8gflAHwAUqATnQFyK4UDaAusRKgDa8AjVBADWzWnQDmzVgQCUiALyVS5eYgDeAKES7EdAKZQQdJPToA6NOmo9+Q0XK0BfLVogIAzlETA4dNCgABTgRA2QEJRQMajYAcgAhEEFUT1QTOOI4gGEAC3o0MAATAzpMxDiAZQBHEBg6KF4DOK5EanRQ8IQFZUQOsIiwCyg4AFV0dFLs1INqOSd3Lzgmi144SWo-ANRgzsGFAHoDxDYAIgTRgBkEgEFKm9GAJVPiU+yACRvHgFkbgDkACIAUWer0qAEVRthHgAVS5A04cIA"
  load={false}
/>

If we look at `formatPokemon` it's infered as `string[]` and `map` has the signature type of `map<string, string>(arr: string[], callback: (arg: string) => string): string[]` as we would expect.

## Generic Interface

An **interface** can also be generic:

```ts:playground.ts
interface Dictionary<Type> {
  [key: string]: Type
}

interface Pokemon {
  name: string
  hp: number
  pokemonType: string
}

interface Consumable {
  name: string
  amount: number
}

const pokemon: Dictionary<Pokemon> = {
  1: { name: 'Bulbasaur', hp: 45, pokemonType: 'grass' },
  2: { name: 'Charmander', hp: 39, pokemonType: 'fire' },
  3: { name: 'Squirtle', hp: 44, pokemonType: 'water' }
}

const consumables: Dictionary<Consumable> = {
  1: { name: 'Antidote', amount: 4 },
  2: { name: 'Potion', amount: 8 },
  3: { name: 'Elixir', amount: 2 }
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCLAWYB7EcoCeAPACoEAOEAfMgN4BQyTyA2gNYQEBcyAzmFFABzALo8ylegF969UJFiIUABWwcAtrjqNmedRB79BIITqYALcjxABXdQCNoZ5OTURNICQb4Dh02fLQ8EjIAMK4vHZw9gA2KAzMyHreRn6JcJo24NZ2jlD+9AgRYC5uHjzomDh4hESqGrg0ALzaiQCMPLRJGd4A5ABCNjH2cLxwNlC9ADTIljwALACsM64NnhR9QlCjvL3IUlPOAEyd3fo8vaHm+OpwIAAm0NOzVsgAzACcK2W4XhcwwCgED2B2cb1OyQuAGUAI42QFgOLPObIebzb5rP7IXoAdzgChBBSKIH4yGJkVusQgvAqGCwuHwxHCJKiVOarWYHToZz6AEFwMB7thIM8MtgsmAFvtDokTtzIdjVPSQKLMtlkAAOaVgiE9C4AURiwAAHoDVeL1Ud9gUgA"
  load={false}
/>

We're creating a generic interface `Dictionary` where we accept any `string` as the object key and it's property has to match the shape of `Type`.

## Generic Constraints

So far we've seen **generics** that work with any kind of value. We can use a **constraint** to limit what a type parameter can accept.

We use the `extends` keyword to say that `Type` has to have a `length` property limiting what we can pass to an array, string or a custom object with that property:

```ts:playground.ts
interface Length {
  length: number
}

function itemLength<Type extends Length>(item: Type) {
  return item.length
}

const pokemonArrayLength = itemLength(['Bulbasaur', 'Charmander', 'Squirtle']);

const singlePokemonLength = itemLength('Pikachu')

// Argument of type 'number' is not assignable to parameter of type 'Length'. üö´
const numberLength = itemLength(1)

console.log(pokemonArrayLength) // 3
console.log(singlePokemonLength) // 7
console.log(numberLength) // undefined
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgDIRAczAC2QbwChkTkAbDbHALmRAFcBbAI2kIF9DCZ6QExgAexDJgkRuiy4APABUAngAcUEAB6QQAEwDOaSrgB8ACjERGtBcoCUBYqSgQw9KCNOMAdBSk4OXBMO0wZEVBAGszYQBBKCg4eUkqZABeUXEE3CMAbQByACF6MmY4bThnbIAaZGyAYRw4KEY4LWgKqoBlAEd6YCgwCmyAXSsAbj8AoO1QTAoABTCIkHS8FLclo2yZ4FDEHHpsqy4AekPkaMwmDCDBGGQwJRRshhYW0V0QQSDiycwQOGYKW6CYL1OCMRzQZDXW73KpLbLuZCAXg3ANV7hH8IECdCYrCgS2SqTMawAjAc0QFBBRPIJMEYQuFGFEYnEljZjsgAMxkjEUiBUmmTLCzeYMxb6HCsk4Adi52h5fKMTxxLOQbN4mggMFAEE0QA"
  load={false}
/>

In the `sortPokemon` example we constrain the shape of `pokemon` to the `Pokemon` interface:

```ts:playground.ts
interface Pokemon {
  name: string
  hp: number
}

type Stat = 'hp'

function sortPokemon<Type extends Pokemon>(pokemon: Type[], stat: Stat): Type[] {
  return pokemon.sort((firstEl, secondEl) => secondEl[stat] - firstEl[stat])
}

const pokemon: Pokemon[] = [
  {
    name: 'Charmander',
    hp: 39
  },
  {
    name: 'Charmeleon',
    hp: 58
  },
  {
    name: 'Charizard',
    hp: 78
  },
]

// sort Pokemon by highest stat
console.log(sortPokemon(pokemon, 'hp'))
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHsDWEC26TIDeAUMmciHDhAFzIDOYUoA5qeQBYAOdIArjgBG0YgF9ixMAE8uKAMpg4YZAF5kAcm7qJMPiARhg+BuihgM2PCAA8AFRkoIAD0ggAJvTRZc+AHwAKLm8rOntZAG0AXQAaBkUwOgUlAEpQhyiidjIoCDA+KAIgy3wAOnpTMH9-GGAoRgBRABtY+ggEfDcm5NVfBjaOpvDGJUjkAFpkGrqwQeGwSOSxCXaQRmQinxA6C02MtXCszPJjiipaDQBhDjgoHDh3aHVow+PuOgBmAE5D0WfjkhO5Eo1Do6iuN2ojQg+CeL04PGQAFYABw-P7kAGA04gy7XZgALxublhWOQb2QAHZUcdfsRIhIAPQMkxmLzFAiCKRk4AsDgQNZzYgrcpQkqNdAsfzlMw7KyBYL4WKaLjqZLJIA"
  load={false}
/>

TypeScript generics are flexible. üí™

## Generic Constraints Using Type Parameters

Let's take this `object` for example:

```js:example.js
const pokemon = {
  hp: 35,
  name: 'Pikachu',
  pokemonType: 'electric'
}
```

In JavaScript to get the keys of an `object` we can do:

```js:example.js
Object.keys(pokemon) // ["hp", "name", "pokemonType"]
```

We can do the type equivalent in TypeScript to make sure the property exists using the `keyof` type operator:

```ts:playground.ts
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key]
}

const pokemon = {
  hp: 35,
  name: 'Pikachu',
  pokemonType: 'electric'
}

// the property 'hp' exists on `pokemon` ‚úÖ
getProperty(pokemon, 'hp')

// Argument of type '"oops"' is not assignable to parameter of type '"hp" | "name" | "pokemonType"'. üö´
getProperty(pokemon, 'oops')
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAcwKZQAoCc4AdVZQCeAPACpH4A0iA0qkYqgB5SpgAmAzogNYNxgiCvgB8ACjgAjAFYAuYZVQ1+RBfSIBKRAG8AUIkOIs6EFiTSZAbVUBdPQF89eiAi5REuOPwC2CRAC8ugZGABa4CgDMAKxUIYZgAIY+qAoA5BgwvIkQoSBpcUae3qh+YCKpiGmoADao0FgwEGmOzmiYOPiEROJevgg0aeFpmnrt2HgExL0lZYNweFwjQA"
  load={false}
/>

The `keyof` operator takes an object type and produces a string or numeric literal union of its keys.

## Enums

**Enums** are a set of named constants.

You might be familiar with enums from other languages. Enums are a feature of TypeScript. They don't exist in JavaScript.

In JavaScript it's popular to create a object with some constants to reduce the amount of typos:

```js:example.js
const direction = {
  up: 'UP',
  right: 'RIGHT',
  down: 'DOWN',
  left: 'LEFT'
}
```

```js:example.js
function movePokemonOnBoard(direction) {
  console.log(direction) // 'UP'
}

movePokemonOnBoard(direction.up)
```

This is also useful for some dynamic code:

```js:example.js
function movePokemonOnBoard(direction) {
  console.log(direction) // whatever we passed
}

movePokemonOnBoard(direction[direction])
```

Enums are what you could use in such a case:

```ts:playground.ts
enum Direction {
  Up = 'UP',
  Right = 'RIGHT',
  Down = 'DOWN',
  Left = 'LEFT'
}

function movePokemonOnBoard(direction: Direction) {
  console.log(direction) // UP
}

movePokemonOnBoard(Direction.Up)
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQDkRAClQDQFQBKcA5gBaoXUsCSAcQASAFUbMYGAO7ZKVGAHkA6gDkJhADLAAZj3maAogDFxeAL548OsCDSZsEDADdgtDAGtgTkIpAAhDABDBAATAApQxBR0LAAuWGj7LABKXGZCZCwAZwwAG2AAOjyMdkik2JA0gHpq4loLKydXdy8fP0CQiPgkZJBC0hSgA"
  load={false}
/>

TypeScript compiles Enums down to some _interesting_ üßê JavaScript code you can look at in the JavaScript output tab if you're curious.

```js:output.js
"use strict"

var Direction

(function (Direction) {
    Direction["Up"] = "UP"
    Direction["Right"] = "RIGHT"
    Direction["Down"] = "DOWN"
    Direction["Left"] = "LEFT"
})(Direction || (Direction = {}))

function movePokemonOnBoard(direction) {
  console.log(direction)
}

movePokemonOnBoard(Direction.Up)
```

This looks like a _fun_ interview question.

I almost never use them but you can [learn more about enums](https://www.typescriptlang.org/docs/handbook/enums.html) if you're interested.

## Tuple

A **tuple** is an array with a fixed number of elements.

Use a tuple where the order is important:

```ts:playground.ts
type RGBColor = [number, number, number]

const color: RGBColor = [255, 255, 255]
```

You can specify optional values:

```ts:playground.ts
type RGBAColor = [number, number, number, number?]

const color: RGBAColor = [255, 255, 255, 0.4]
```

üó∫Ô∏è Cartesian coordinates anyone?

```ts:playground.ts
type CartesianCoordinates = [x, y]

const coordinates: CartesianCoordinates = [3, 4]
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/PTAECUHECFQYwPYBsECdQBcCuAHJBTAKAwE8d8IYBhZNUAXlAG0A7LAWwCN9UAaUNlx79B3PgI5iAuoUKIWAZwyhUAc040UqAFyVomuoyYAmAKyn+Zi6Cv8ADADoALDMIg9AQXi102PEVJyTwN0I1FhCSFxcOjJHgB+V3klFXUAQxDdKGgPEIZmWxtzS2LQRxdZdyo01Ax8BQBLNJZvNAATBpY0uoVMXAJiMgpq2vqmlhp2zu76-KYAD10Y-hIluNQkhEVlRCmunt0RnvHJ1A792aMAZn4XIA"
  load={false}
/>

I might expand this with more examples.

## Classes

Using TypeScript doesn't mean you have to use classes. That being said let's explore what TypeScript adds to classes.

If you're unfamiliar with classes you can [read about Classes from the MDN Web Docs](https://www.typescriptlang.org/docs/handbook/2/classes.html).

**readonly**

`readonly` prevents assignments to the field outside of the constructor:

```ts:playground.ts
class Pokemon {
  readonly name: string

  constructor(name: string) {
    this.name = name
  }
}

const pokemon = new Pokemon('Pikachu')

// Cannot assign to 'name' because it is a read-only property. üö´
pokemon.name = 'Charizard'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKD2BrApgW3gO2gbwFDQOgCdkwATTEAT2gzFWQC5oIAXIgSwwHNd9DgmNkQCuwVvCIAKOg2bCu3AJQ5+hQqwAWHCADpZyaAF5a9ZGugBfXNdyCMbaAAckaTMdrIA7nFfoMUgDksByIYMCaIoFKfAD0sdAAwmAYGPCs0JAQHNxYEtCBBoHQAEbIwGAiEIYcGTqZxKRkALSUNE5E8E7IRKxUutCAvBuA1Xu4Lij++mYegYmaYJwAXgtkgUA"
  load={false}
/>

**public**

A `public` member can be accessed anywhere (default):

```ts:playground.ts
class Pokemon {
  public name: string

  constructor(name: string) {
    this.name = name
  }
}

const pokemon = new Pokemon('Pikachu')

pokemon.name = 'Charizard' // no problem ‚úÖ
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKD2BrApgW3gO2gbwFDQOgAcBXAIxAEthoMxVkAuaCAFwCdKMBzXfQ4JjbsSwVvHYAKOg2bCu3AJQ5+hQqwAWlCADoZyaAF5a9ZKugBfXFdyCMbYkjSYjtZAHc4T9BkkByWEpEMGANEj9FPiJvTD1TVz8AYQ0wTgAvVIATP2gAelzaeGJ2eAo0aEBQciA"
  load={false}
/>

**protected**

`protected` members are only visible to subclasses of the class they‚Äôre declared in:

```ts:playground.ts
class Pokemon {
  protected name: string

  constructor(name: string) {
    this.name = name
  }
}

class LogPokemon extends Pokemon {
  public logPokemon() {
    console.log(this.name)
  }
}

const pokemon = new LogPokemon('Pikachu')

// Property 'name' is protected and only accessible within
// class 'Pokemon' and its subclasses. üö´
pokemon.name

// no problem ‚úÖ
pokemon.logPokemon() // 'Pikachu'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKD2BrApgW3gO2gbwFDQOgAcAneAF2WEoBNoMxVkAuaCckgSwwHNd9CwTOxIBXavBIAKBk1YjuPAJQ4BhQuQAWnCADpZyaAF56jZGugBfXNdyhIMADLweCFOizIAHpQw0YbmiYqupEogBGIJzA0CAugR5SKnjq6kIYEPAgyLpxPFJaOvpmShbWtunsxEhBWCYYyADu0M6uNYkA5LCciGDAmqIdpbgA9CNwZETIJOQAntAdBh3QOsRklNTIdGB+0Jgg833AyFCckYaNnIUYo+P2UAsJmMs7dFcwEBH3ECe60IC8G4BqvdwRHamGKTH4Y3o8DW8HOqGggFByEFgjC5eJopLQaFdHp9AYdIA"
  load={false}
/>

**private**

`private` is like protected, but doesn‚Äôt allow access to the member even from subclasses:

```ts:playground.ts
class Pokemon {
  private name: string

  constructor(name: string) {
    this.name = name
  }
}

class LogPokemon extends Pokemon {
  public logPokemon() {
    // Property 'name' is private and only
    // accessible within class 'Pokemon'. üö´
    console.log(this.name)
  }
}

const pokemon = new LogPokemon('Pikachu')

// Property 'name' is protected and only accessible within
// class 'Pokemon' and its subclasses. üö´
pokemon.name

// no problem ‚úÖ
pokemon.logPokemon() // 'Pikachu'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKD2BrApgW3gO2gbwFDQOgAcAnASwDcwAXZaDMVZALmgmvIwHNd9DhM7EgFdg1eCQAUDJqyFluAShx9ChagAsyEAHQy6AXnqNkq6AF9cl3KEgwAMvC4IU6LMgAetDABMYLtEwVNSJhACMQMmBoECcAt0llPDU1AHpUuBJ4ImQSagBPaAByfSLobWJyKlpoMF9oTBB8szSMsGBgZCgyCLoAdzJNBWhbKGL4zCKdaEBeDcBqvZb+QXgQZB1Yrkkh3X1FM0trAQx2YiRArCMMZD7oR2czhKLYMkR2jWEivdx0zOzcguKpXKMFI8FoYmQPlq9UahXanW6vWgAyGGG+GVGMCeD0m0KhgxgEHCmK603muCIOIwehMvB+GHglXgvVQ0EAoOQUqnrOJUxLQH5PF5vD5AA"
  load={false}
/>

**Parameter properties**

TypeScript let's us write a shorter syntax for declaring a class property from the constructor using **parameter properties** by prefixing it with `public`, `private`, `protected`, or `readonly`:

```ts:playground.ts
class Pokemon {
  constructor(public name: string) {
    // no body necessary
  }
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKD2BrApgW3gO2gbwFDQOmEwgBcAnAV2FPnIAoAHSgIxAEthoMxVkAuaGXLsMAcwCUOfIVkB6Od3jQW8ACYBPbsmDIoYchpkEAvrhNA"
  load={false}
/>

We can see the equivalent in the transpiled output:

```js:example.js
class Pokemon {
  constructor(name) {
    this.name = name
  }
}
```

**Interfaces**

**Interfaces** are _implemented_ ü§≠ using the `implements` keyword:

```ts:playground.ts
interface LogPokemon {
  logPokemon(): void
}

class Pokemon implements LogPokemon {
  constructor(public name: string) {}

  public logPokemon() {
    console.log(this.name)
  }
}

class Pokedex implements LogPokemon {
  // Property 'logPokemon' is missing in type 'Pokedex' but
  // required in type 'LogPokemon'. üö´
}
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgDIHsDmAFdBrCAW3RGQG8AoZa5AGy1wOJAAoBKALmQDd1gATCgF8KFBLTgBnSckZESyYIQAOtIhHAyMOfPNKUayBCUlgoAVwRh0UFsvMAjWsATIQcQhC6mooTG3IRKhp7Jxc6Bl1mdnJgw2pjEEl0NQA6ekwWMAALYElU9082OOQRIPEpGTl+CAAPRRU1T000SKYFAxoAei7ZKHRlaDAAT2QAcgy5ZjHFGUI8yT9FUhHB8eq6mYdzMBKe5CgIAEdzYEP+ZeRVlDHtKZIx1ORAXg3Aar3hIA"
  load={false}
/>

**Generics**

The syntax of a **generic** class is similar to a **generic** interface syntax:

```ts:playground.ts
class Pokemon<Type> {
  constructor(public pokemon: Type) {}
}

// Pokemon<string> ‚úÖ
const pokemonString = new Pokemon('Pikachu')

// Pokemon<string[]> ‚úÖ
const pokemonArray = new Pokemon(['Bulbasaur', 'Charmander', 'Squirtle'])
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKD2BrApgW3gOwDwBUCeADsgHzQDeAUNNdMJhAC4BOArsA-EwBQEsBGIAJbBoBJGkwAuaPiIBKcgF8KyigHo1ccemyMmgjAHNSgUHIKdDI1HbMAZWYHD0ALzQMyAO5aUOrgHJYQUQwYAALFj85CnVNBB9MLD1HAG0AXVNzegZreIwAQSYmMDwXN09vCQwuZL8AIRYQPkgwFiY-ABpoPwBhULAmVDAMABNkNs6-WwBHFkEmBhBkP1S5IA"
  load={false}
/>

**Abstract classes and members**

An **abstract class** is like a contract used by other classes to extend from. It doesn't contain implementation and can't be instantiated.

```ts:playground.ts
abstract class Pokemon {
  constructor(public name: string) {}

  abstract useItem(item: string): void
}

class FirePokemon extends Pokemon {
  useItem(item: string) {
    console.log(`${this.name} used üß™ ${item}`)
  }
}

const charizard = new FirePokemon('Charizard')

charizard.useItem('Potion') // 'Charizard used üß™ Potion.'
```

<Iframe
  title="TypeScript Playground"
  src="https://www.typescriptlang.org/play?#code/IYIwzgLgTsDGEAJYBthjAgCgewNYFMBbbAOwQG8AoBGpUyKAV3mygAoAHRkZAS1gQlghfAC4EDXiQDmASgoBfStVqgGcRIzD4AkhCJte+wuMkzZ4gG7ZeAE0pLKKNBgBivKPhwFiZfAA99ElsMbyJSChUaLV1jQ2NTaCk5SNo0uhIwbGR8ADpkbGk2AAMAEnIIAAteMFyhEQUEGNsEQD4NwCvdhHKjIgVc4tkohCVHWHpEWErgKF4AL2mWgF5BfAB3BHdPMN82AHIAYSmZ+ahbXcGnI7mF3Ji9A12cCF5Sc4QAeneEA6uTlua2p0ni8SLldkA"
  load={false}
/>

We glanced over classes in TypeScript because it's a large topic deserving it's own post. If classes are something you use and want to learn more about using in TypeScript [read the Classes section in the TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/2/classes.html).

## Set Up TypeScript

You're probably learning TypeScript to use with a JavaScript framework. That's great because most popular JavaScript frameworks require zero configuration for enabling TypeScript support. You can consult the docs for your framework how to set that up.

If you want to use vanilla TypeScript if you're working on a passion project I highly recommend you use [Vite](https://vitejs.dev/) to set up your project. It's simple as running `npm init @vitejs/app` and picking a template. Vite has a [template preset](https://vitejs.dev/guide/#scaffolding-your-first-vite-project) for other frameworks. Try it out.

I'm going to show you how to set up TypeScript (it's easy) from scratch and show you around the TypeScript compiler settings.

Start by initializing a project inside an empty folder:

```shell:terminal
npm init -y
```

Install TypeScript as a development dependency:

```shell:terminal
npm i -D typescript
```

Create a `app.ts` file at the root:

```shell:terminal
touch app.ts
```

```ts:app.ts
const pokemon: string = 'Pikachu'
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/17-typescript-setup.png"
  alt="TypeScript setup"
/>

Since the browser or Node doesn't understand TypeScript we have to transpile the TypeScript code to JavaScript:

```shell:terminal
npx tsc app.ts
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/18-typescript-compiler.png"
  alt="Description"
/>

[npm](https://www.npmjs.com/) includes a tool `npx` that runs executables without having to install a package globally. It just downloads the binary to your `.bin` folder in `node_modules` and removes it when you're done. The `tsc` command invokes the TypeScript compiler.

We can observe a `app.js` file has been created. This is what your browser and Node are going to run. TypeScript doesn't save you at runtime.

It would be a drag having to run this each time on change. We can pass a watch flag to the TypeScript compiler:

```shell:terminal
npx tsc app.ts -w
```

It's easier to include it as a script in `package.json`:

```json:package.json
{
  "name": "typescript",
  "scripts": {
    "dev": "npx tsc app.ts -w"
  },
  "devDependencies": {
    "typescript": "^4.3.5"
  }
}
```

```shell:terminal
npm run dev
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/19-typescript-watch.png"
  alt="TypeScript watch"
/>

If you're using TypeScript with a site and want live reload you can use [live-server](https://www.npmjs.com/package/live-server). You can run live server and TypeScript at the same time:

```json:package.json
{
  "name": "example",
  "scripts": {
    "dev": "live-server && npx tsc pokemon.ts -w"
  },
  "devDependencies": {
    "typescript": "^4.3.5"
  }
}
```

```html:example.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>TypeScript</title>
    <script src="app.js" defer></script>
  </head>
  <body>
    <h1>TypeScript</h1>
  </body>
</html>
```

If you're a Node chad you can use [ts-node](https://www.npmjs.com/package/ts-node) that let's you run TypeScript files with `ts-node app.ts`. You also get a live code environment (REPL) if you run `ts-node` (`npx ts-node` üëç) like you do using `node`. If you're using `ts-node` you can use [nodemon](https://www.npmjs.com/package/nodemon) to watch the files by creating a `nodemon app.ts` script in `package.json`.

<Image
  height={304}
  width={655}
  src="/images/typescript-fundamentals/20-typescript-ts-node.png"
  alt="ts-node"
/>

Tooling is a subject that deserves it's own post. I just want to expose you to what is out there.

Let's look at the TypeScript compiler options. TypeScript looks for a `tsconfig.json` file that we can create by hand or generate.

Using the `--init` flag we can generate `tsconfig.json`:

```shell:terminal
npx tsc --init
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/21-typescript-tsconfig.png"
  alt="TSConfig"
/>

If we look at the generated `tsconfig.json` config we can see useful descriptions alongside the options.

You can look at the [TypeScript compiler options](https://www.typescriptlang.org/docs/handbook/compiler-options.html) and the [TSConfig Reference](https://www.typescriptlang.org/tsconfig) that explains each option if you want to learn more.

I'm going to remove most of it for sake of readability. Let's look at some common compiler options instead.

```json:tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "lib": ["ESNext", "DOM"],
    "outDir": "./dist",
    "rootDir": "./src",
    "noEmitOnError": true,
    "strict": true
  }
}
```

- **target** specifies the target JavaScript version the TypeScript code compiles to where **ESNext** is the latest
- **module** specifies the module system we're going to transpile to where [CommonJS](https://en.wikipedia.org/wiki/CommonJS) is using the `const package = require('package')` syntax and the **ES6** and onwards option uses **ECMAScript modules** (**ESM**) `import package from 'package'` which are only supported natively in browsers as of recently
- **lib** let us decide what types to include with our code because we might not need **DOM** types if we're writing for Node or want to target some other JavaScript features (TypeScript includes a default set of type definitions for built-in JavaScript APIs)
- **outDir** specifies the output directory for transpiled JavaScript code
- **rootDir** specifies the root directory for TypeScript files
- **noEmirOnError** is not going to output anything if there's a TypeScript error
- **strict** enables all the strict flags so our code is more type-safe

In the example I set the **rootDir** as `src` and **outDir** as `dist`. Since we set the **rootDir** we don't have specify what file to run since it watches the entire directory:

```json:package.json
"scripts": {
  "dev": "npx tsc -w"
},
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/22-typescript-output.png"
  alt="TypeScript output"
/>

If you want to fire up a quick demo you can use an online editor like [CodeSandbox](https://codesandbox.io/) so you can try things out.

Hope this helps you get started using TypeScript.

## Reading Type Definitions

TypeScript gives us documentation inside our editor. We can go beyond using code completion and dive into the types directly to understand the surface area of an API.

This is something that requires practice if you just started to learn TypeScript.

```ts:example.ts
const pokemon: Array<string> = ['Bulbasaur', 'Charmander', 'Squirtle']
```

We can inspect the **generic** `Array` interface by selecting `Array` and pressing <kbd>F12</kbd> or right-clicking it and selecting **Go to Definition**.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/23-array-es2015-interface.png"
  alt="es2015 interface"
/>

There's always going to be a lot of information in these but focus on what you're inspecting. We can leap-frog from type definition to type definition by doing the same to other types inside.

There's a couple of interesting things to note:

- The file ends with a `.d.ts` extension which is just a declaration file for types (this is used to add TypeScript types to things that aren't built with TypeScript)
- There's multiple type declarations on the right depending on the version of JavaScript the features were added in among other things (remember it's one **interface** since we can declare it again)

If we poke around **lib.es2015.core.d.ts** more we can find the types that describe how to create arrays.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/24-array-constructor.png"
  alt="Array constructor"
/>

If we look at **lib.es5.d.ts** it looks like something we would expect. You can double-click on it or <kbd>Alt</kbd> + <kbd>Click</kbd> on the type definition to open it.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/25-array-es5-interface.png"
  alt="es5 interface"
/>

This has the properties we would expect like `length`, `pop`, `push`, `map` and more.

We can learn how they typed the `map` array method:

```ts:example.ts
interface Array<T> {
  // ...
  map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[]
  // ...
}
```

You can get a real idea how **generics** are used in practice.

## Reading TypeScript Errors

Arguably, the hardest part about TypeScript can be reading and understanding errors.

First open the **problems** tab in your editor so you have an easier time reading TypeScript errors.

```ts:example.ts
const pokemon = {
  bulbasaur: { id: 1, hp: 45, attack: 49, defense: 49 },
  charmander: { id: 2, hp: 39, attack: 52, defense: 43 },
  squirtle: { id: 3, hp: 44, attack: 48, defense: 65 },
}

const bulbasaur: string = 'bulbasaur'

const chosenPokemon = pokemon[bulbasaur] // TypeScript is mad. üö´
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/26-problems-tab.png"
  alt="Problems tab"
/>

```json:error
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ bulbasaur: { id: number; hp: number; attack: number; defense: number; }; charmander: { id: number; hp: number; attack: number; defense: number; }; squirtle: { id: number; hp: number; attack: number; defense: number; }; }'.
  No index signature with a parameter of type 'string' was found on type '{ bulbasaur: { id: number; hp: number; attack: number; defense: number; }; charmander: { id: number; hp: number; attack: number; defense: number; }; squirtle: { id: number; hp: number; attack: number; defense: number; }; }'.
```

Sometimes you're going to have these sort of errors that make you question your sanity when using TypeScript when it's a simple fix.

The error message is verbose because it's describing the entire object as a literal type since we're not using a **type alias** or **interface** it can refer to instead.

```json:error
Element implicitly has an 'any' type because expression of type 'Pokemon'.
  No index signature with a parameter of type 'string' was found on type 'Pokemon'.
```

This is the first lesson to not get overwhelmed. Just read the error calmly.

We can read TypeScript errors like sentences with **because** inbetween:

```json:error
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type ...
  because no index signature with a parameter of type 'string' was found on type ...
```

This further you go down the chain the more specific the error is, so start from there.

This problem might be harder to reason about if you don't understand things like **object index signatures** in TypeScript. Everything we learn ties together.

The second part of the error message reveals the problem. We don't care if `chosenPokemon` type is `any` because that's what TypeScript cares about. We care about what causes it.

This is what TypeScript thinks is going on:

```ts:example.ts
// TypeScript sees the general type `string` üö´
const chosenPokemon = pokemon['random string']

// it expects the literal type `bulbasaur` ‚úÖ
const chosenPokemon = pokemon['bulbasaur']
```

This goes back to how objects are number indexed by default. TypeScript freaks out because it thinks we're passing some random string since we haven't specified the **index signature**.

```ts:example.ts
interface Pokemon {
  [index: string]: {
    id: number
    hp: number
    attack: number
    defense: number
  }
}

const pokemon: Pokemon = {
  bulbasaur: { id: 1, hp: 45, attack: 49, defense: 49 },
  charmander: { id: 2, hp: 39, attack: 52, defense: 43 },
  squirtle: { id: 3, hp: 44, attack: 48, defense: 65 },
}

const bulbasaur: string = 'bulbasaur'

const chosenPokemon = pokemon[bulbasaur] // ok ‚úÖ
```

That works but it's not what we want. We just want TypeScript to infer the type for us here so we don't have to do it by hand.

If we did this by hand we would have to update the interface each time there's another Pokemon:

```ts:example.ts
interface Pokemon {
  bulbasaur: {
    id: number
    hp: number
    attack: number
    defense: number
  }
  charmander: {
    id: number
    hp: number
    attack: number
    defense: number
  }
  squirtle: {
    id: number
    hp: number
    attack: number
    defense: number
  }
}
```

In our case the problem is that we're not passing the type literal `bulbasaur` so TypeScript can compare it to the key `bulbasaur` in `pokemon`.

```ts:example.ts
const pokemon = {
  bulbasaur: { id: 1, hp: 45, attack: 49, defense: 49 },
  charmander: { id: 2, hp: 39, attack: 52, defense: 43 },
  squirtle: { id: 3, hp: 44, attack: 48, defense: 65 },
}

const bulbasaur: 'bulbasaur' = 'bulbasaur'

const chosenPokemon = pokemon[bulbasaur]
```

If you used `const` it would infer it as a literal type, so the type assignment isn't required and it's only there so it's obvious.

You're going to get into this situation often when dealing with dynamic values, so I hope you remember it.

There's times when TypeScript goes _cuckoo for Cocoa Puffs_ and something goes wrong. Instead of closing and opening your editor just restart the TypeScript server by pressing <kbd>F1</kbd> to open the **command palette** in VS Code and find "TypeScript: Restart TS server".

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/27-restart-ts-server.png"
  alt="Restart TS server"
/>

If you don't understand the error open up the [TypeScript Playground](https://www.typescriptlang.org/play/) and reproduce it there. This is also great because now you have a shareable link you can send to anyone. If you have doubts you can always ask a question in the [TypeScript Community Discord Server](https://discord.com/invite/typescript).

## Dealing With Untyped Libraries

Almost every library you want to use supports TypeScript today.

The great thing about TypeScript is that the community can gather around to create types for libraries that don't use TypeScript.

**Ambient declarations** describe the types that would have been there if the project was written in TypeScript and they have the `.d.ts` file extension that TypeScript picks up.

[DefinitelyTyped](https://definitelytyped.org/) is a project that holds a repository for types that everyone gathered around for to contribute types to that has over **76,000** commits. It's used to [search for types](https://www.typescriptlang.org/dt/search?search=) on the official TypeScript page.

<Image
  height={843}
  width={1300}
  src="/images/typescript-fundamentals/28-type-search.png"
  alt="Type search"
/>

```ts:app.ts
// Cannot find name 'require'.
// Do you need to install type definitions for node?
// Try `npm i --save-dev @types/node`. üö´
const http = require('http')

// Parameter 'req' implicitly has an 'any' type. üö´
// Parameter 'res' implicitly has an 'any' type. üö´
function requestListener(req, res) {
  res.writeHead(200, { 'Content-Type': 'application/json' })
  res.end(JSON.stringify({ pokemon: 'Pikachu' }))
}

const server = http.createServer(requestListener)
server.listen(8080)
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/29-type-definitions.png"
  alt="Type definitions"
/>

In the example we're creating a simple HTTP server in Node that sends a JSON response.

You don't have to use search to figure out if what you're using is typed or not. TypeScript is going to let you know.

Let's install the types for Node:

```shell:terminal
npm i -D @types/node
```

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/30-require-to-import.png"
  alt="Require to import"
/>

TypeScript let's us know we can convert `require` to an `import`:

```ts:app.ts
import * as http from 'http'
```

You have to keep in mind these older libraries use **commonjs** that uses module exports, so we can't expect it to use **ECMAScript modules** where you can import a package simply as `import http from 'http` using the default export or `import { http } from http` if it's a named import. Try it first and if it doesn't work you can use `import * as http from 'http'` to import the entire module's contents.

You can brush up on how JavaScript modules work by reading [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) on the MDN Web Docs.

We still haven't resolved the types for `req` and `res` for `requestListener`. We can't do that alone by just installing type definitions. How do we figure these out?

We can always search for the answer and that's a valid approach but let's dig through the type definitions to figure it out.

Let's select the `http` part and press <kbd>F12</kbd> to "Go to Definition". This is going to open the `http.d.ts` type declaration file.

Inside the file we can do a <kbd>Ctrl</kbd> + <kbd>F</kbd> search for `requestListener`. If that wouldn't work we coud look for `req` or `res` until we find something.

<Image
  height={768}
  width={1024}
  src="/images/typescript-fundamentals/31-type-declaration-search.png"
  alt="Type declaration search"
/>

We found our types! The `req` argument expects `IncomingMessage` and the `res` argument expects `ServerResponse`.

We can import the types from `http`:

```ts:app.ts
import * as http from 'http'

import type { IncomingMessage, ServerResponse } from 'http'
```

The `type` keyword is optional but it makes it clear we're using types and not importing some method.

```ts:app.ts
import * as http from 'http'

import type { IncomingMessage, ServerResponse } from 'http'

function requestListener(req: IncomingMessage, res: ServerResponse) {
  res.writeHead(200, { 'Content-Type': 'application/json' })
  res.end(JSON.stringify({ pokemon: 'Pikachu' }))
}

const server = http.createServer(requestListener)
server.listen(8080)
```

Now we have the entire `http` API at our fingertips and look at the options without leaving our editor.

Using types is easy in most cases when it's properly documented in a project that uses TypeScript. I wanted to show you how to deal with a scenario where that isn't the case.

In the rare case when there's no types for a package you can create a `index.d.ts` file and place it someplace such as inside a `types` folder. The name could be anything.

```ts:index.d.ts
declare module 'http'
```

This says to TypeScript the package exists and it's going to stop bothering you.

## Generate Types

In case where we have some complex JSON object from an API response we can generate types from it to make our lives easier instead of typing it out by hand.

We can use [quicktype](https://quicktype.io/) to generate types for more than just TypeScript. There's also a [quicktype extension for VS Code](https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype).

Their default example uses Pokemon, so it's perfect! Consistency. üí™

<Image
  height={843}
  width={1300}
  src="/images/typescript-fundamentals/32-quicktype.png"
  alt="quicktype"
/>

This is also great as a learning tool.

## Closing Thoughts

You learned a lot about TypeScript fundamentals to give you confidence in using it in your projects. TypeScript itself is a tool that gives confidence about your code but don't forget it doesn't save you at runtime.

If you think TypeScript makes code harder to read and you write more code you're not wrong. TypeScript might not be for everyone. I'm confident that if you give it a try and get a taste of the developer experience you might not want to go back.

TypeScript is only gaining more popularity and since more projects are using TypeScript that means we as developers have to step up if we want to contribute to those projects.

Even if TypeScript fades and JavaScript gets types we didn't have to learn another language to use types because TypeScript is JavaScript.

There's a lot more to learn about TypeScript. Using TypeScript to type out a library is another game. Did you know you can use conditional logic in your types? I'll leave that for another post. ü§≠

Thank you for your time! üòÑ
